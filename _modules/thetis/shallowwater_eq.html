<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">


<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    
    <title>thetis.shallowwater_eq &#8212; Thetis 0+untagged.833.g086f878 documentation</title>
    
    <link rel="stylesheet" href="../../_static/thetis.css" type="text/css" />
    <link rel="stylesheet" href="../../_static/pygments.css" type="text/css" />
    
    <script type="text/javascript">
      var DOCUMENTATION_OPTIONS = {
        URL_ROOT:    '../../',
        VERSION:     '0+untagged.833.g086f878',
        COLLAPSE_INDEX: false,
        FILE_SUFFIX: '.html',
        HAS_SOURCE:  true,
        SOURCELINK_SUFFIX: '.txt'
      };
    </script>
    <script type="text/javascript" src="../../_static/jquery.js"></script>
    <script type="text/javascript" src="../../_static/underscore.js"></script>
    <script type="text/javascript" src="../../_static/doctools.js"></script>
    <script type="text/javascript" src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
    <link rel="index" title="Index" href="../../genindex.html" />
    <link rel="search" title="Search" href="../../search.html" />
<!--[if lte IE 6]>
<link rel="stylesheet" href="../../_static/ie6.css" type="text/css" media="screen" charset="utf-8" />
<![endif]-->

<!-- <link rel="stylesheet" href="../../_static/featured.css"> -->


<link rel="shortcut icon" href="../../_static/icon_thetis.ico" />


  </head>
  <body role="document">
<div class="wrapper">
  <a href="../../index.html"><img src="../../_static/banner.png" height="180px" alt="Thetis Project Banner" /></a>
  <div id="access">
    <div class="menu">
      <ul>
        <li class="page_item"><a href="../../documentation.html" title="Thetis documentation">Documentation</a></li>
        <li class="page_item"><a href="../../download.html" title="Install Thetis">Download</a></li>
        <li class="page_item"><a href="../../team.html" title="Development team">Team</a></li>
        <li class="page_item"><a href="../../publications.html" title="Publications">Publications</a></li>
        <li class="page_item"><a href="../../funding.html" title="Our financial supporters">Funding</a></li>
        <li class="page_item"><a href="../../contact.html" title="Getting in touch">Contact</a></li>
        <li class="page_item"><a href="https://github.com/thetisproject/thetis" title="Thetis source on GitHub">GitHub</a></li>
        <li class="page_item"><a href="https://travis-ci.org/thetisproject/thetis" title="Thetis on Travis">Travis</a></li>
      </ul>
    </div><!-- .menu -->
  </div><!-- #access -->
</div><!-- #wrapper -->


    <div class="document">
    <div class="_modules/thetis/shallowwater_eq">
      
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body" role="main">
            
  <h1>Source code for thetis.shallowwater_eq</h1><div class="highlight"><pre>
<span></span><span class="sd">r&quot;&quot;&quot;</span>
<span class="sd">Depth averaged shallow water equations</span>

<span class="sd">---------</span>
<span class="sd">Equations</span>
<span class="sd">---------</span>

<span class="sd">The state variables are water elevation, :math:`\eta`, and depth averaged</span>
<span class="sd">velocity :math:`\bar{\textbf{u}}`.</span>

<span class="sd">Denoting the total water depth by :math:`H=\eta + h`, the non-conservative form of</span>
<span class="sd">the free surface equation is</span>

<span class="sd">.. math::</span>
<span class="sd">   \frac{\partial \eta}{\partial t} + \nabla \cdot (H \bar{\textbf{u}}) = 0</span>
<span class="sd">   :label: swe_freesurf</span>

<span class="sd">The non-conservative momentum equation reads</span>

<span class="sd">.. math::</span>
<span class="sd">   \frac{\partial \bar{\textbf{u}}}{\partial t} +</span>
<span class="sd">   \bar{\textbf{u}} \cdot \nabla\bar{\textbf{u}} +</span>
<span class="sd">   f\textbf{e}_z\wedge \bar{\textbf{u}} +</span>
<span class="sd">   g \nabla \eta +</span>
<span class="sd">   g \frac{1}{H}\int_{-h}^\eta \nabla r dz</span>
<span class="sd">   = \nabla \cdot \big( \nu_h ( \nabla \bar{\textbf{u}} + (\nabla \bar{\textbf{u}})^T )\big) +</span>
<span class="sd">   \frac{\nu_h \nabla(H)}{H} \cdot ( \nabla \bar{\textbf{u}} + (\nabla \bar{\textbf{u}})^T ),</span>
<span class="sd">   :label: swe_momentum</span>

<span class="sd">where :math:`g` is the gravitational acceleration, :math:`f` is the Coriolis</span>
<span class="sd">frequency, :math:`\wedge` is the cross product,</span>
<span class="sd">:math:`\textbf{e}_z` is a vertical unit vector, and :math:`\nu_h`</span>
<span class="sd">is viscosity. Water density is given by :math:`\rho = \rho&#39;(T, S, p) + \rho_0`,</span>
<span class="sd">where :math:`\rho_0` is a constant reference density.</span>

<span class="sd">Above :math:`r` denotes the baroclinic head</span>

<span class="sd">.. math::</span>

<span class="sd">  r = \frac{1}{\rho_0} \int_{z}^\eta  \rho&#39; d\zeta.</span>

<span class="sd">In the case of purely barotropic problems the :math:`r` and the internal pressure</span>
<span class="sd">gradient are omitted.</span>

<span class="sd">If the option :attr:`.ModelOptions.nonlin` is ``False``, we solve the linear shallow water</span>
<span class="sd">equations (i.e. wave equation):</span>

<span class="sd">.. math::</span>
<span class="sd">   \frac{\partial \eta}{\partial t} + \nabla \cdot (h \bar{\textbf{u}}) = 0</span>
<span class="sd">   :label: swe_freesurf_linear</span>

<span class="sd">.. math::</span>
<span class="sd">   \frac{\partial \bar{\textbf{u}}}{\partial t} +</span>
<span class="sd">   f\textbf{e}_z\wedge \bar{\textbf{u}} +</span>
<span class="sd">   g \nabla \eta</span>
<span class="sd">   = \nabla \cdot \big( \nu_h ( \nabla \bar{\textbf{u}} + (\nabla \bar{\textbf{u}})^T )\big) +</span>
<span class="sd">   \frac{\nu_h \nabla(H)}{H} \cdot ( \nabla \bar{\textbf{u}} + (\nabla \bar{\textbf{u}})^T ).</span>
<span class="sd">   :label: swe_momentum_linear</span>

<span class="sd">In case of a 3D problem with mode splitting, we use a simplified 2D</span>
<span class="sd">system that contains nothing but the rotational external gravity waves:</span>

<span class="sd">.. math::</span>
<span class="sd">    \frac{\partial \eta}{\partial t} + \nabla \cdot (H \bar{\textbf{u}}) = 0</span>
<span class="sd">    :label: swe_freesurf_modesplit</span>

<span class="sd">.. math::</span>
<span class="sd">    \frac{\partial \bar{\textbf{u}}}{\partial t} +</span>
<span class="sd">    f\textbf{e}_z\wedge \bar{\textbf{u}} +</span>
<span class="sd">    g \nabla \eta + g \frac{1}{H}\int_{-h}^\eta \nabla r dz</span>
<span class="sd">    = \textbf{G},</span>
<span class="sd">    :label: swe_momentum_modesplit</span>

<span class="sd">where :math:`\textbf{G}` is a source term used to couple the 2D and 3D momentum</span>
<span class="sd">equations.</span>

<span class="sd">-------------------</span>
<span class="sd">Boundary Conditions</span>
<span class="sd">-------------------</span>

<span class="sd">All boundary conditions are imposed weakly by providing external values for</span>
<span class="sd">:math:`\eta` and :math:`\bar{\textbf{u}}`.</span>

<span class="sd">Boundary conditions are set with a dictionary that defines all prescribed</span>
<span class="sd">variables at each open boundary.</span>
<span class="sd">For example, to assign elevation and volume flux on boundary ``1`` we set</span>

<span class="sd">.. code-block:: python</span>

<span class="sd">    swe_bnd_funcs = {}</span>
<span class="sd">    swe_bnd_funcs[1] = {&#39;elev&#39;:myfunc1, &#39;flux&#39;:myfunc2}</span>

<span class="sd">where ``myfunc1`` and ``myfunc2`` are :class:`Constant` or :class:`Function`</span>
<span class="sd">objects.</span>

<span class="sd">The user can provide :math:`\eta` and/or :math:`\bar{\textbf{u}}` values.</span>
<span class="sd">Supported combinations are:</span>

<span class="sd">- *unspecified* : impermeable (land) boundary, implies symmetric :math:`\eta` condition and zero normal velocity</span>
<span class="sd">- ``&#39;elev&#39;``: elevation only, symmetric velocity (usually unstable)</span>
<span class="sd">- ``&#39;uv&#39;``: 2d velocity vector :math:`\bar{\textbf{u}}=(u, v)` (in mesh coordinates), symmetric elevation</span>
<span class="sd">- ``&#39;un&#39;``: normal velocity (scalar, positive out of domain), symmetric elevation</span>
<span class="sd">- ``&#39;flux&#39;``: normal volume flux (scalar, positive out of domain), symmetric elevation</span>
<span class="sd">- ``&#39;elev&#39;`` and ``&#39;uv&#39;``: water elevation and 2d velocity vector</span>
<span class="sd">- ``&#39;elev&#39;`` and ``&#39;un&#39;``: water elevation and normal velocity</span>
<span class="sd">- ``&#39;elev&#39;`` and ``&#39;flux&#39;``: water elevation and normal flux</span>

<span class="sd">The boundary conditions are assigned to the :class:`.FlowSolver2d` or</span>
<span class="sd">:class:`.FlowSolver` objects:</span>

<span class="sd">.. code-block:: python</span>

<span class="sd">    solver_obj = solver2d.FlowSolver2d(...)</span>
<span class="sd">    ...</span>
<span class="sd">    solver_obj.bnd_functions[&#39;shallow_water&#39;] = swe_bnd_funcs</span>

<span class="sd">Internally the boundary conditions passed to the :meth:`.Term.residual` method</span>
<span class="sd">of each term:</span>

<span class="sd">.. code-block:: python</span>

<span class="sd">    adv_term = shallowwater_eq.HorizontalAdvectionTerm(...)</span>
<span class="sd">    adv_form = adv_term.residual(..., bnd_conditions=swe_bnd_funcs)</span>

<span class="sd">&quot;&quot;&quot;</span>
<span class="kn">from</span> <span class="nn">__future__</span> <span class="k">import</span> <span class="n">absolute_import</span>
<span class="kn">from</span> <span class="nn">.utility</span> <span class="k">import</span> <span class="o">*</span>
<span class="kn">from</span> <span class="nn">.equation</span> <span class="k">import</span> <span class="n">Term</span><span class="p">,</span> <span class="n">Equation</span>

<span class="n">__all__</span> <span class="o">=</span> <span class="p">[</span>
    <span class="s1">&#39;BaseShallowWaterEquation&#39;</span><span class="p">,</span>
    <span class="s1">&#39;ShallowWaterEquations&#39;</span><span class="p">,</span>
    <span class="s1">&#39;ModeSplit2DEquations&#39;</span><span class="p">,</span>
    <span class="s1">&#39;ShallowWaterMomentumEquation&#39;</span><span class="p">,</span>
    <span class="s1">&#39;FreeSurfaceEquation&#39;</span><span class="p">,</span>
    <span class="s1">&#39;ShallowWaterTerm&#39;</span><span class="p">,</span>
    <span class="s1">&#39;ShallowWaterMomentumTerm&#39;</span><span class="p">,</span>
    <span class="s1">&#39;ShallowWaterContinuityTerm&#39;</span><span class="p">,</span>
    <span class="s1">&#39;HUDivTerm&#39;</span><span class="p">,</span>
    <span class="s1">&#39;ContinuitySourceTerm&#39;</span><span class="p">,</span>
    <span class="s1">&#39;HorizontalAdvectionTerm&#39;</span><span class="p">,</span>
    <span class="s1">&#39;HorizontalViscosityTerm&#39;</span><span class="p">,</span>
    <span class="s1">&#39;ExternalPressureGradientTerm&#39;</span><span class="p">,</span>
    <span class="s1">&#39;InternalPressureGradientTerm&#39;</span><span class="p">,</span>
    <span class="s1">&#39;CoriolisTerm&#39;</span><span class="p">,</span>
    <span class="s1">&#39;LinearDragTerm&#39;</span><span class="p">,</span>
    <span class="s1">&#39;QuadraticDragTerm&#39;</span><span class="p">,</span>
    <span class="s1">&#39;BottomDrag3DTerm&#39;</span><span class="p">,</span>
    <span class="s1">&#39;MomentumSourceTerm&#39;</span><span class="p">,</span>
    <span class="s1">&#39;WindStressTerm&#39;</span><span class="p">,</span>
<span class="p">]</span>

<span class="n">g_grav</span> <span class="o">=</span> <span class="n">physical_constants</span><span class="p">[</span><span class="s1">&#39;g_grav&#39;</span><span class="p">]</span>
<span class="n">rho_0</span> <span class="o">=</span> <span class="n">physical_constants</span><span class="p">[</span><span class="s1">&#39;rho0&#39;</span><span class="p">]</span>


<div class="viewcode-block" id="ShallowWaterTerm"><a class="viewcode-back" href="../../thetis.html#thetis.shallowwater_eq.ShallowWaterTerm">[docs]</a><span class="k">class</span> <span class="nc">ShallowWaterTerm</span><span class="p">(</span><span class="n">Term</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Generic term in the shallow water equations that provides commonly used</span>
<span class="sd">    members and mapping for boundary functions.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">space</span><span class="p">,</span>
                 <span class="n">bathymetry</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                 <span class="n">nonlin</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
        <span class="nb">super</span><span class="p">(</span><span class="n">ShallowWaterTerm</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="n">__init__</span><span class="p">(</span><span class="n">space</span><span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">bathymetry</span> <span class="o">=</span> <span class="n">bathymetry</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">nonlin</span> <span class="o">=</span> <span class="n">nonlin</span>

        <span class="c1"># mesh dependent variables</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">cellsize</span> <span class="o">=</span> <span class="n">CellSize</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">mesh</span><span class="p">)</span>

        <span class="c1"># define measures with a reasonable quadrature degree</span>
        <span class="n">p</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">function_space</span><span class="o">.</span><span class="n">ufl_element</span><span class="p">()</span><span class="o">.</span><span class="n">degree</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">quad_degree</span> <span class="o">=</span> <span class="mi">2</span><span class="o">*</span><span class="n">p</span> <span class="o">+</span> <span class="mi">1</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">dx</span> <span class="o">=</span> <span class="n">dx</span><span class="p">(</span><span class="n">degree</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">quad_degree</span><span class="p">,</span>
                     <span class="n">domain</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">function_space</span><span class="o">.</span><span class="n">ufl_domain</span><span class="p">())</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">dS</span> <span class="o">=</span> <span class="n">dS</span><span class="p">(</span><span class="n">degree</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">quad_degree</span><span class="p">,</span>
                     <span class="n">domain</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">function_space</span><span class="o">.</span><span class="n">ufl_domain</span><span class="p">())</span>

<div class="viewcode-block" id="ShallowWaterTerm.get_bnd_functions"><a class="viewcode-back" href="../../thetis.html#thetis.shallowwater_eq.ShallowWaterTerm.get_bnd_functions">[docs]</a>    <span class="k">def</span> <span class="nf">get_bnd_functions</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">eta_in</span><span class="p">,</span> <span class="n">uv_in</span><span class="p">,</span> <span class="n">bnd_id</span><span class="p">,</span> <span class="n">bnd_conditions</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns external values of elev and uv for all supported</span>
<span class="sd">        boundary conditions.</span>

<span class="sd">        Volume flux (flux) and normal velocity (un) are defined positive out of</span>
<span class="sd">        the domain.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">bath</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">bathymetry</span>
        <span class="n">bnd_len</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">boundary_len</span><span class="p">[</span><span class="n">bnd_id</span><span class="p">]</span>
        <span class="n">funcs</span> <span class="o">=</span> <span class="n">bnd_conditions</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">bnd_id</span><span class="p">)</span>
        <span class="k">if</span> <span class="s1">&#39;elev&#39;</span> <span class="ow">in</span> <span class="n">funcs</span> <span class="ow">and</span> <span class="s1">&#39;uv&#39;</span> <span class="ow">in</span> <span class="n">funcs</span><span class="p">:</span>
            <span class="n">eta_ext</span> <span class="o">=</span> <span class="n">funcs</span><span class="p">[</span><span class="s1">&#39;elev&#39;</span><span class="p">]</span>
            <span class="n">uv_ext</span> <span class="o">=</span> <span class="n">funcs</span><span class="p">[</span><span class="s1">&#39;uv&#39;</span><span class="p">]</span>
        <span class="k">elif</span> <span class="s1">&#39;elev&#39;</span> <span class="ow">in</span> <span class="n">funcs</span> <span class="ow">and</span> <span class="s1">&#39;un&#39;</span> <span class="ow">in</span> <span class="n">funcs</span><span class="p">:</span>
            <span class="n">eta_ext</span> <span class="o">=</span> <span class="n">funcs</span><span class="p">[</span><span class="s1">&#39;elev&#39;</span><span class="p">]</span>
            <span class="n">uv_ext</span> <span class="o">=</span> <span class="n">funcs</span><span class="p">[</span><span class="s1">&#39;un&#39;</span><span class="p">]</span><span class="o">*</span><span class="bp">self</span><span class="o">.</span><span class="n">normal</span>
        <span class="k">elif</span> <span class="s1">&#39;elev&#39;</span> <span class="ow">in</span> <span class="n">funcs</span> <span class="ow">and</span> <span class="s1">&#39;flux&#39;</span> <span class="ow">in</span> <span class="n">funcs</span><span class="p">:</span>
            <span class="n">eta_ext</span> <span class="o">=</span> <span class="n">funcs</span><span class="p">[</span><span class="s1">&#39;elev&#39;</span><span class="p">]</span>
            <span class="n">h_ext</span> <span class="o">=</span> <span class="n">eta_ext</span> <span class="o">+</span> <span class="n">bath</span>
            <span class="n">area</span> <span class="o">=</span> <span class="n">h_ext</span><span class="o">*</span><span class="n">bnd_len</span>  <span class="c1"># NOTE using external data only</span>
            <span class="n">uv_ext</span> <span class="o">=</span> <span class="n">funcs</span><span class="p">[</span><span class="s1">&#39;flux&#39;</span><span class="p">]</span><span class="o">/</span><span class="n">area</span><span class="o">*</span><span class="bp">self</span><span class="o">.</span><span class="n">normal</span>
        <span class="k">elif</span> <span class="s1">&#39;elev&#39;</span> <span class="ow">in</span> <span class="n">funcs</span><span class="p">:</span>
            <span class="n">eta_ext</span> <span class="o">=</span> <span class="n">funcs</span><span class="p">[</span><span class="s1">&#39;elev&#39;</span><span class="p">]</span>
            <span class="n">uv_ext</span> <span class="o">=</span> <span class="n">uv_in</span>  <span class="c1"># assume symmetry</span>
        <span class="k">elif</span> <span class="s1">&#39;uv&#39;</span> <span class="ow">in</span> <span class="n">funcs</span><span class="p">:</span>
            <span class="n">eta_ext</span> <span class="o">=</span> <span class="n">eta_in</span>  <span class="c1"># assume symmetry</span>
            <span class="n">uv_ext</span> <span class="o">=</span> <span class="n">funcs</span><span class="p">[</span><span class="s1">&#39;uv&#39;</span><span class="p">]</span>
        <span class="k">elif</span> <span class="s1">&#39;un&#39;</span> <span class="ow">in</span> <span class="n">funcs</span><span class="p">:</span>
            <span class="n">eta_ext</span> <span class="o">=</span> <span class="n">eta_in</span>  <span class="c1"># assume symmetry</span>
            <span class="n">uv_ext</span> <span class="o">=</span> <span class="n">funcs</span><span class="p">[</span><span class="s1">&#39;un&#39;</span><span class="p">]</span><span class="o">*</span><span class="bp">self</span><span class="o">.</span><span class="n">normal</span>
        <span class="k">elif</span> <span class="s1">&#39;flux&#39;</span> <span class="ow">in</span> <span class="n">funcs</span><span class="p">:</span>
            <span class="n">eta_ext</span> <span class="o">=</span> <span class="n">eta_in</span>  <span class="c1"># assume symmetry</span>
            <span class="n">h_ext</span> <span class="o">=</span> <span class="n">eta_ext</span> <span class="o">+</span> <span class="n">bath</span>
            <span class="n">area</span> <span class="o">=</span> <span class="n">h_ext</span><span class="o">*</span><span class="n">bnd_len</span>  <span class="c1"># NOTE using internal elevation</span>
            <span class="n">uv_ext</span> <span class="o">=</span> <span class="n">funcs</span><span class="p">[</span><span class="s1">&#39;flux&#39;</span><span class="p">]</span><span class="o">/</span><span class="n">area</span><span class="o">*</span><span class="bp">self</span><span class="o">.</span><span class="n">normal</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="s1">&#39;Unsupported bnd type: </span><span class="si">{:}</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">funcs</span><span class="o">.</span><span class="n">keys</span><span class="p">()))</span>
        <span class="k">return</span> <span class="n">eta_ext</span><span class="p">,</span> <span class="n">uv_ext</span></div>

<div class="viewcode-block" id="ShallowWaterTerm.get_total_depth"><a class="viewcode-back" href="../../thetis.html#thetis.shallowwater_eq.ShallowWaterTerm.get_total_depth">[docs]</a>    <span class="k">def</span> <span class="nf">get_total_depth</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">eta</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns total water column depth</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">nonlin</span><span class="p">:</span>
            <span class="n">total_h</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">bathymetry</span> <span class="o">+</span> <span class="n">eta</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">total_h</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">bathymetry</span>
        <span class="k">return</span> <span class="n">total_h</span></div></div>


<div class="viewcode-block" id="ShallowWaterMomentumTerm"><a class="viewcode-back" href="../../thetis.html#thetis.shallowwater_eq.ShallowWaterMomentumTerm">[docs]</a><span class="k">class</span> <span class="nc">ShallowWaterMomentumTerm</span><span class="p">(</span><span class="n">ShallowWaterTerm</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Generic term in the shallow water momentum equation that provides commonly used</span>
<span class="sd">    members and mapping for boundary functions.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">u_test</span><span class="p">,</span> <span class="n">u_space</span><span class="p">,</span> <span class="n">eta_space</span><span class="p">,</span>
                 <span class="n">bathymetry</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                 <span class="n">nonlin</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
                 <span class="n">include_grad_div_viscosity_term</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
                 <span class="n">include_grad_depth_viscosity_term</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
        <span class="nb">super</span><span class="p">(</span><span class="n">ShallowWaterMomentumTerm</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="n">__init__</span><span class="p">(</span><span class="n">u_space</span><span class="p">,</span> <span class="n">bathymetry</span><span class="p">,</span> <span class="n">nonlin</span><span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">include_grad_div_viscosity_term</span> <span class="o">=</span> <span class="n">include_grad_div_viscosity_term</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">include_grad_depth_viscosity_term</span> <span class="o">=</span> <span class="n">include_grad_depth_viscosity_term</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">u_test</span> <span class="o">=</span> <span class="n">u_test</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">u_space</span> <span class="o">=</span> <span class="n">u_space</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">eta_space</span> <span class="o">=</span> <span class="n">eta_space</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">u_is_dg</span> <span class="o">=</span> <span class="n">element_continuity</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">u_space</span><span class="o">.</span><span class="n">fiat_element</span><span class="p">)</span><span class="o">.</span><span class="n">dg</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">eta_is_dg</span> <span class="o">=</span> <span class="n">element_continuity</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">eta_space</span><span class="o">.</span><span class="n">fiat_element</span><span class="p">)</span><span class="o">.</span><span class="n">dg</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">u_is_hdiv</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">u_space</span><span class="o">.</span><span class="n">ufl_element</span><span class="p">()</span><span class="o">.</span><span class="n">family</span><span class="p">()</span> <span class="o">==</span> <span class="s1">&#39;Raviart-Thomas&#39;</span></div>


<div class="viewcode-block" id="ShallowWaterContinuityTerm"><a class="viewcode-back" href="../../thetis.html#thetis.shallowwater_eq.ShallowWaterContinuityTerm">[docs]</a><span class="k">class</span> <span class="nc">ShallowWaterContinuityTerm</span><span class="p">(</span><span class="n">ShallowWaterTerm</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Generic term in the depth-integrated continuity equation that provides commonly used</span>
<span class="sd">    members and mapping for boundary functions.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">eta_test</span><span class="p">,</span> <span class="n">eta_space</span><span class="p">,</span> <span class="n">u_space</span><span class="p">,</span>
                 <span class="n">bathymetry</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                 <span class="n">nonlin</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
        <span class="nb">super</span><span class="p">(</span><span class="n">ShallowWaterContinuityTerm</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="n">__init__</span><span class="p">(</span><span class="n">eta_space</span><span class="p">,</span> <span class="n">bathymetry</span><span class="p">,</span> <span class="n">nonlin</span><span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">bathymetry</span> <span class="o">=</span> <span class="n">bathymetry</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">nonlin</span> <span class="o">=</span> <span class="n">nonlin</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">eta_test</span> <span class="o">=</span> <span class="n">eta_test</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">eta_space</span> <span class="o">=</span> <span class="n">eta_space</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">u_space</span> <span class="o">=</span> <span class="n">u_space</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">u_is_dg</span> <span class="o">=</span> <span class="n">element_continuity</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">u_space</span><span class="o">.</span><span class="n">fiat_element</span><span class="p">)</span><span class="o">.</span><span class="n">dg</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">eta_is_dg</span> <span class="o">=</span> <span class="n">element_continuity</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">eta_space</span><span class="o">.</span><span class="n">fiat_element</span><span class="p">)</span><span class="o">.</span><span class="n">dg</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">u_is_hdiv</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">u_space</span><span class="o">.</span><span class="n">ufl_element</span><span class="p">()</span><span class="o">.</span><span class="n">family</span><span class="p">()</span> <span class="o">==</span> <span class="s1">&#39;Raviart-Thomas&#39;</span></div>


<div class="viewcode-block" id="ExternalPressureGradientTerm"><a class="viewcode-back" href="../../thetis.html#thetis.shallowwater_eq.ExternalPressureGradientTerm">[docs]</a><span class="k">class</span> <span class="nc">ExternalPressureGradientTerm</span><span class="p">(</span><span class="n">ShallowWaterMomentumTerm</span><span class="p">):</span>
    <span class="sd">r&quot;&quot;&quot;</span>
<span class="sd">    External pressure gradient term, :math:`g \nabla \eta`</span>

<span class="sd">    The weak form reads</span>

<span class="sd">    .. math::</span>
<span class="sd">        \int_\Omega g \nabla \eta \cdot \boldsymbol{\psi} dx</span>
<span class="sd">        = \int_\Gamma g \eta^* \text{jump}(\boldsymbol{\psi} \cdot \textbf{n}) dS</span>
<span class="sd">        - \int_\Omega g \eta \nabla \cdot \boldsymbol{\psi} dx</span>

<span class="sd">    where the right hand side has been integrated by parts; :math:`\textbf{n}`</span>
<span class="sd">    denotes the unit normal of the element interfaces, :math:`n^*` is value at</span>
<span class="sd">    the interface obtained from an approximate Riemann solver.</span>

<span class="sd">    If :math:`\eta` belongs to a discontinuous function space, the form on the</span>
<span class="sd">    right hand side is used.</span>
<span class="sd">    &quot;&quot;&quot;</span>
<div class="viewcode-block" id="ExternalPressureGradientTerm.residual"><a class="viewcode-back" href="../../thetis.html#thetis.shallowwater_eq.ExternalPressureGradientTerm.residual">[docs]</a>    <span class="k">def</span> <span class="nf">residual</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">uv</span><span class="p">,</span> <span class="n">eta</span><span class="p">,</span> <span class="n">uv_old</span><span class="p">,</span> <span class="n">eta_old</span><span class="p">,</span> <span class="n">fields</span><span class="p">,</span> <span class="n">fields_old</span><span class="p">,</span> <span class="n">bnd_conditions</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="n">total_h</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_total_depth</span><span class="p">(</span><span class="n">eta_old</span><span class="p">)</span>

        <span class="n">head</span> <span class="o">=</span> <span class="n">eta</span>

        <span class="n">grad_eta_by_parts</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">eta_is_dg</span>

        <span class="k">if</span> <span class="n">grad_eta_by_parts</span><span class="p">:</span>
            <span class="n">f</span> <span class="o">=</span> <span class="o">-</span><span class="n">g_grav</span><span class="o">*</span><span class="n">head</span><span class="o">*</span><span class="n">nabla_div</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">u_test</span><span class="p">)</span><span class="o">*</span><span class="bp">self</span><span class="o">.</span><span class="n">dx</span>
            <span class="k">if</span> <span class="n">uv</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">head_star</span> <span class="o">=</span> <span class="n">avg</span><span class="p">(</span><span class="n">head</span><span class="p">)</span> <span class="o">+</span> <span class="mf">0.5</span><span class="o">*</span><span class="n">sqrt</span><span class="p">(</span><span class="n">avg</span><span class="p">(</span><span class="n">total_h</span><span class="p">)</span><span class="o">/</span><span class="n">g_grav</span><span class="p">)</span><span class="o">*</span><span class="n">jump</span><span class="p">(</span><span class="n">uv</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">normal</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">head_star</span> <span class="o">=</span> <span class="n">avg</span><span class="p">(</span><span class="n">head</span><span class="p">)</span>
            <span class="n">f</span> <span class="o">+=</span> <span class="n">g_grav</span><span class="o">*</span><span class="n">head_star</span><span class="o">*</span><span class="n">jump</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">u_test</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">normal</span><span class="p">)</span><span class="o">*</span><span class="bp">self</span><span class="o">.</span><span class="n">dS</span>
            <span class="k">for</span> <span class="n">bnd_marker</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">boundary_markers</span><span class="p">:</span>
                <span class="n">funcs</span> <span class="o">=</span> <span class="n">bnd_conditions</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">bnd_marker</span><span class="p">)</span>
                <span class="n">ds_bnd</span> <span class="o">=</span> <span class="n">ds</span><span class="p">(</span><span class="nb">int</span><span class="p">(</span><span class="n">bnd_marker</span><span class="p">),</span> <span class="n">degree</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">quad_degree</span><span class="p">)</span>
                <span class="k">if</span> <span class="n">funcs</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                    <span class="n">eta_ext</span><span class="p">,</span> <span class="n">uv_ext</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_bnd_functions</span><span class="p">(</span><span class="n">head</span><span class="p">,</span> <span class="n">uv</span><span class="p">,</span> <span class="n">bnd_marker</span><span class="p">,</span> <span class="n">bnd_conditions</span><span class="p">)</span>
                    <span class="c1"># Compute linear riemann solution with eta, eta_ext, uv, uv_ext</span>
                    <span class="n">un_jump</span> <span class="o">=</span> <span class="n">inner</span><span class="p">(</span><span class="n">uv</span> <span class="o">-</span> <span class="n">uv_ext</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">normal</span><span class="p">)</span>
                    <span class="n">eta_rie</span> <span class="o">=</span> <span class="mf">0.5</span><span class="o">*</span><span class="p">(</span><span class="n">head</span> <span class="o">+</span> <span class="n">eta_ext</span><span class="p">)</span> <span class="o">+</span> <span class="n">sqrt</span><span class="p">(</span><span class="n">total_h</span><span class="o">/</span><span class="n">g_grav</span><span class="p">)</span><span class="o">*</span><span class="n">un_jump</span>
                    <span class="n">f</span> <span class="o">+=</span> <span class="n">g_grav</span><span class="o">*</span><span class="n">eta_rie</span><span class="o">*</span><span class="n">dot</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">u_test</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">normal</span><span class="p">)</span><span class="o">*</span><span class="n">ds_bnd</span>
                <span class="k">if</span> <span class="n">funcs</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">or</span> <span class="s1">&#39;symm&#39;</span> <span class="ow">in</span> <span class="n">funcs</span><span class="p">:</span>
                    <span class="c1"># assume land boundary</span>
                    <span class="c1"># impermeability implies external un=0</span>
                    <span class="n">un_jump</span> <span class="o">=</span> <span class="n">inner</span><span class="p">(</span><span class="n">uv</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">normal</span><span class="p">)</span>
                    <span class="n">h</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">bathymetry</span>
                    <span class="n">head_rie</span> <span class="o">=</span> <span class="n">head</span> <span class="o">+</span> <span class="n">sqrt</span><span class="p">(</span><span class="n">h</span><span class="o">/</span><span class="n">g_grav</span><span class="p">)</span><span class="o">*</span><span class="n">un_jump</span>
                    <span class="n">f</span> <span class="o">+=</span> <span class="n">g_grav</span><span class="o">*</span><span class="n">head_rie</span><span class="o">*</span><span class="n">dot</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">u_test</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">normal</span><span class="p">)</span><span class="o">*</span><span class="n">ds_bnd</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">f</span> <span class="o">=</span> <span class="n">g_grav</span><span class="o">*</span><span class="n">inner</span><span class="p">(</span><span class="n">grad</span><span class="p">(</span><span class="n">head</span><span class="p">),</span> <span class="bp">self</span><span class="o">.</span><span class="n">u_test</span><span class="p">)</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">dx</span>
            <span class="k">for</span> <span class="n">bnd_marker</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">boundary_markers</span><span class="p">:</span>
                <span class="n">funcs</span> <span class="o">=</span> <span class="n">bnd_conditions</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">bnd_marker</span><span class="p">)</span>
                <span class="n">ds_bnd</span> <span class="o">=</span> <span class="n">ds</span><span class="p">(</span><span class="nb">int</span><span class="p">(</span><span class="n">bnd_marker</span><span class="p">),</span> <span class="n">degree</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">quad_degree</span><span class="p">)</span>
                <span class="k">if</span> <span class="n">funcs</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                    <span class="n">eta_ext</span><span class="p">,</span> <span class="n">uv_ext</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_bnd_functions</span><span class="p">(</span><span class="n">head</span><span class="p">,</span> <span class="n">uv</span><span class="p">,</span> <span class="n">bnd_marker</span><span class="p">,</span> <span class="n">bnd_conditions</span><span class="p">)</span>
                    <span class="c1"># Compute linear riemann solution with eta, eta_ext, uv, uv_ext</span>
                    <span class="n">un_jump</span> <span class="o">=</span> <span class="n">inner</span><span class="p">(</span><span class="n">uv</span> <span class="o">-</span> <span class="n">uv_ext</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">normal</span><span class="p">)</span>
                    <span class="n">eta_rie</span> <span class="o">=</span> <span class="mf">0.5</span><span class="o">*</span><span class="p">(</span><span class="n">head</span> <span class="o">+</span> <span class="n">eta_ext</span><span class="p">)</span> <span class="o">+</span> <span class="n">sqrt</span><span class="p">(</span><span class="n">total_h</span><span class="o">/</span><span class="n">g_grav</span><span class="p">)</span><span class="o">*</span><span class="n">un_jump</span>
                    <span class="n">f</span> <span class="o">+=</span> <span class="n">g_grav</span><span class="o">*</span><span class="p">(</span><span class="n">eta_rie</span><span class="o">-</span><span class="n">head</span><span class="p">)</span><span class="o">*</span><span class="n">dot</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">u_test</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">normal</span><span class="p">)</span><span class="o">*</span><span class="n">ds_bnd</span>
        <span class="k">return</span> <span class="o">-</span><span class="n">f</span></div></div>


<div class="viewcode-block" id="HUDivTerm"><a class="viewcode-back" href="../../thetis.html#thetis.shallowwater_eq.HUDivTerm">[docs]</a><span class="k">class</span> <span class="nc">HUDivTerm</span><span class="p">(</span><span class="n">ShallowWaterContinuityTerm</span><span class="p">):</span>
    <span class="sd">r&quot;&quot;&quot;</span>
<span class="sd">    Divergence term, :math:`\nabla \cdot (H \bar{\textbf{u}})`</span>

<span class="sd">    The weak form reads</span>

<span class="sd">    .. math::</span>
<span class="sd">        \int_\Omega \nabla \cdot (H \bar{\textbf{u}}) \phi dx</span>
<span class="sd">        = \int_\Gamma (H^* \bar{\textbf{u}}^*) \cdot \text{jump}(\phi \textbf{n}) dS</span>
<span class="sd">        - \int_\Omega H (\bar{\textbf{u}}\cdot\nabla \phi) dx</span>

<span class="sd">    where the right hand side has been integrated by parts; :math:`\textbf{n}`</span>
<span class="sd">    denotes the unit normal of the element interfaces, and :math:`\text{jump}`</span>
<span class="sd">    and :math:`\text{avg}` denote the jump and average operators across the</span>
<span class="sd">    interface. :math:`H^*, \bar{\textbf{u}}^*` are values at the interface</span>
<span class="sd">    obtained from an approximate Riemann solver.</span>

<span class="sd">    If :math:`\bar{\textbf{u}}` belongs to a discontinuous function space,</span>
<span class="sd">    the form on the right hand side is used.</span>
<span class="sd">    &quot;&quot;&quot;</span>
<div class="viewcode-block" id="HUDivTerm.residual"><a class="viewcode-back" href="../../thetis.html#thetis.shallowwater_eq.HUDivTerm.residual">[docs]</a>    <span class="k">def</span> <span class="nf">residual</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">uv</span><span class="p">,</span> <span class="n">eta</span><span class="p">,</span> <span class="n">uv_old</span><span class="p">,</span> <span class="n">eta_old</span><span class="p">,</span> <span class="n">fields</span><span class="p">,</span> <span class="n">fields_old</span><span class="p">,</span> <span class="n">bnd_conditions</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="n">total_h</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_total_depth</span><span class="p">(</span><span class="n">eta_old</span><span class="p">)</span>

        <span class="n">hu_by_parts</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">u_is_dg</span> <span class="ow">or</span> <span class="bp">self</span><span class="o">.</span><span class="n">u_is_hdiv</span>

        <span class="k">if</span> <span class="n">hu_by_parts</span><span class="p">:</span>
            <span class="n">f</span> <span class="o">=</span> <span class="o">-</span><span class="n">inner</span><span class="p">(</span><span class="n">grad</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">eta_test</span><span class="p">),</span> <span class="n">total_h</span><span class="o">*</span><span class="n">uv</span><span class="p">)</span><span class="o">*</span><span class="bp">self</span><span class="o">.</span><span class="n">dx</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">eta_is_dg</span><span class="p">:</span>
                <span class="n">h</span> <span class="o">=</span> <span class="n">avg</span><span class="p">(</span><span class="n">total_h</span><span class="p">)</span>
                <span class="n">uv_rie</span> <span class="o">=</span> <span class="n">avg</span><span class="p">(</span><span class="n">uv</span><span class="p">)</span> <span class="o">+</span> <span class="n">sqrt</span><span class="p">(</span><span class="n">g_grav</span><span class="o">/</span><span class="n">h</span><span class="p">)</span><span class="o">*</span><span class="n">jump</span><span class="p">(</span><span class="n">eta</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">normal</span><span class="p">)</span>
                <span class="n">hu_star</span> <span class="o">=</span> <span class="n">h</span><span class="o">*</span><span class="n">uv_rie</span>
                <span class="n">f</span> <span class="o">+=</span> <span class="n">inner</span><span class="p">(</span><span class="n">jump</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">eta_test</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">normal</span><span class="p">),</span> <span class="n">hu_star</span><span class="p">)</span><span class="o">*</span><span class="bp">self</span><span class="o">.</span><span class="n">dS</span>
            <span class="k">for</span> <span class="n">bnd_marker</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">boundary_markers</span><span class="p">:</span>
                <span class="n">funcs</span> <span class="o">=</span> <span class="n">bnd_conditions</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">bnd_marker</span><span class="p">)</span>
                <span class="n">ds_bnd</span> <span class="o">=</span> <span class="n">ds</span><span class="p">(</span><span class="nb">int</span><span class="p">(</span><span class="n">bnd_marker</span><span class="p">),</span> <span class="n">degree</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">quad_degree</span><span class="p">)</span>
                <span class="k">if</span> <span class="n">funcs</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                    <span class="n">eta_ext</span><span class="p">,</span> <span class="n">uv_ext</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_bnd_functions</span><span class="p">(</span><span class="n">eta</span><span class="p">,</span> <span class="n">uv</span><span class="p">,</span> <span class="n">bnd_marker</span><span class="p">,</span> <span class="n">bnd_conditions</span><span class="p">)</span>
                    <span class="n">eta_ext_old</span><span class="p">,</span> <span class="n">uv_ext_old</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_bnd_functions</span><span class="p">(</span><span class="n">eta_old</span><span class="p">,</span> <span class="n">uv_old</span><span class="p">,</span> <span class="n">bnd_marker</span><span class="p">,</span> <span class="n">bnd_conditions</span><span class="p">)</span>
                    <span class="c1"># Compute linear riemann solution with eta, eta_ext, uv, uv_ext</span>
                    <span class="n">h_av</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">bathymetry</span> <span class="o">+</span> <span class="mf">0.5</span><span class="o">*</span><span class="p">(</span><span class="n">eta_old</span> <span class="o">+</span> <span class="n">eta_ext_old</span><span class="p">)</span>
                    <span class="n">eta_jump</span> <span class="o">=</span> <span class="n">eta</span> <span class="o">-</span> <span class="n">eta_ext</span>
                    <span class="n">un_rie</span> <span class="o">=</span> <span class="mf">0.5</span><span class="o">*</span><span class="n">inner</span><span class="p">(</span><span class="n">uv</span> <span class="o">+</span> <span class="n">uv_ext</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">normal</span><span class="p">)</span> <span class="o">+</span> <span class="n">sqrt</span><span class="p">(</span><span class="n">g_grav</span><span class="o">/</span><span class="n">h_av</span><span class="p">)</span><span class="o">*</span><span class="n">eta_jump</span>
                    <span class="n">un_jump</span> <span class="o">=</span> <span class="n">inner</span><span class="p">(</span><span class="n">uv_old</span> <span class="o">-</span> <span class="n">uv_ext_old</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">normal</span><span class="p">)</span>
                    <span class="n">eta_rie</span> <span class="o">=</span> <span class="mf">0.5</span><span class="o">*</span><span class="p">(</span><span class="n">eta_old</span> <span class="o">+</span> <span class="n">eta_ext_old</span><span class="p">)</span> <span class="o">+</span> <span class="n">sqrt</span><span class="p">(</span><span class="n">h_av</span><span class="o">/</span><span class="n">g_grav</span><span class="p">)</span><span class="o">*</span><span class="n">un_jump</span>
                    <span class="n">h_rie</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">bathymetry</span> <span class="o">+</span> <span class="n">eta_rie</span>
                    <span class="n">f</span> <span class="o">+=</span> <span class="n">h_rie</span><span class="o">*</span><span class="n">un_rie</span><span class="o">*</span><span class="bp">self</span><span class="o">.</span><span class="n">eta_test</span><span class="o">*</span><span class="n">ds_bnd</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">f</span> <span class="o">=</span> <span class="n">div</span><span class="p">(</span><span class="n">total_h</span><span class="o">*</span><span class="n">uv</span><span class="p">)</span><span class="o">*</span><span class="bp">self</span><span class="o">.</span><span class="n">eta_test</span><span class="o">*</span><span class="bp">self</span><span class="o">.</span><span class="n">dx</span>
            <span class="k">for</span> <span class="n">bnd_marker</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">boundary_markers</span><span class="p">:</span>
                <span class="n">funcs</span> <span class="o">=</span> <span class="n">bnd_conditions</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">bnd_marker</span><span class="p">)</span>
                <span class="n">ds_bnd</span> <span class="o">=</span> <span class="n">ds</span><span class="p">(</span><span class="nb">int</span><span class="p">(</span><span class="n">bnd_marker</span><span class="p">),</span> <span class="n">degree</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">quad_degree</span><span class="p">)</span>
                <span class="k">if</span> <span class="n">funcs</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">or</span> <span class="s1">&#39;un&#39;</span> <span class="ow">in</span> <span class="n">funcs</span><span class="p">:</span>
                    <span class="n">f</span> <span class="o">+=</span> <span class="o">-</span><span class="n">total_h</span><span class="o">*</span><span class="n">dot</span><span class="p">(</span><span class="n">uv</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">normal</span><span class="p">)</span><span class="o">*</span><span class="bp">self</span><span class="o">.</span><span class="n">eta_test</span><span class="o">*</span><span class="n">ds_bnd</span>
        <span class="k">return</span> <span class="o">-</span><span class="n">f</span></div></div>


<div class="viewcode-block" id="HorizontalAdvectionTerm"><a class="viewcode-back" href="../../thetis.html#thetis.shallowwater_eq.HorizontalAdvectionTerm">[docs]</a><span class="k">class</span> <span class="nc">HorizontalAdvectionTerm</span><span class="p">(</span><span class="n">ShallowWaterMomentumTerm</span><span class="p">):</span>
    <span class="sd">r&quot;&quot;&quot;</span>
<span class="sd">    Advection of momentum term, :math:`\bar{\textbf{u}} \cdot \nabla\bar{\textbf{u}}`</span>

<span class="sd">    The weak form is</span>

<span class="sd">    .. math::</span>
<span class="sd">        \int_\Omega \bar{\textbf{u}} \cdot \nabla\bar{\textbf{u}} \cdot \boldsymbol{\psi} dx</span>
<span class="sd">        = - \int_\Omega \nabla_h \cdot (\bar{\textbf{u}} \boldsymbol{\psi}) \cdot \bar{\textbf{u}} dx</span>
<span class="sd">        + \int_\Gamma \text{avg}(\bar{\textbf{u}}) \cdot \text{jump}(\boldsymbol{\psi}</span>
<span class="sd">        (\bar{\textbf{u}}\cdot\textbf{n})) dS</span>

<span class="sd">    where the right hand side has been integrated by parts;</span>
<span class="sd">    :math:`\textbf{n}` is the unit normal of</span>
<span class="sd">    the element interfaces, and :math:`\text{jump}` and :math:`\text{avg}` denote the</span>
<span class="sd">    jump and average operators across the interface.</span>
<span class="sd">    &quot;&quot;&quot;</span>
<div class="viewcode-block" id="HorizontalAdvectionTerm.residual"><a class="viewcode-back" href="../../thetis.html#thetis.shallowwater_eq.HorizontalAdvectionTerm.residual">[docs]</a>    <span class="k">def</span> <span class="nf">residual</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">uv</span><span class="p">,</span> <span class="n">eta</span><span class="p">,</span> <span class="n">uv_old</span><span class="p">,</span> <span class="n">eta_old</span><span class="p">,</span> <span class="n">fields</span><span class="p">,</span> <span class="n">fields_old</span><span class="p">,</span> <span class="n">bnd_conditions</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="n">uv_lax_friedrichs</span> <span class="o">=</span> <span class="n">fields_old</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;uv_lax_friedrichs&#39;</span><span class="p">)</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">nonlin</span><span class="p">:</span>
            <span class="k">return</span> <span class="mi">0</span>

        <span class="n">horiz_advection_by_parts</span> <span class="o">=</span> <span class="kc">True</span>

        <span class="k">if</span> <span class="n">horiz_advection_by_parts</span><span class="p">:</span>
            <span class="c1"># f = -inner(nabla_div(outer(uv, self.u_test)), uv)</span>
            <span class="n">f</span> <span class="o">=</span> <span class="o">-</span><span class="p">(</span><span class="n">Dx</span><span class="p">(</span><span class="n">uv_old</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">*</span><span class="bp">self</span><span class="o">.</span><span class="n">u_test</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="mi">0</span><span class="p">)</span><span class="o">*</span><span class="n">uv</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">+</span>
                  <span class="n">Dx</span><span class="p">(</span><span class="n">uv_old</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">*</span><span class="bp">self</span><span class="o">.</span><span class="n">u_test</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="mi">0</span><span class="p">)</span><span class="o">*</span><span class="n">uv</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">+</span>
                  <span class="n">Dx</span><span class="p">(</span><span class="n">uv_old</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">*</span><span class="bp">self</span><span class="o">.</span><span class="n">u_test</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="mi">1</span><span class="p">)</span><span class="o">*</span><span class="n">uv</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">+</span>
                  <span class="n">Dx</span><span class="p">(</span><span class="n">uv_old</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">*</span><span class="bp">self</span><span class="o">.</span><span class="n">u_test</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="mi">1</span><span class="p">)</span><span class="o">*</span><span class="n">uv</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span><span class="o">*</span><span class="bp">self</span><span class="o">.</span><span class="n">dx</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">u_is_dg</span><span class="p">:</span>
                <span class="n">un_av</span> <span class="o">=</span> <span class="n">dot</span><span class="p">(</span><span class="n">avg</span><span class="p">(</span><span class="n">uv_old</span><span class="p">),</span> <span class="bp">self</span><span class="o">.</span><span class="n">normal</span><span class="p">(</span><span class="s1">&#39;-&#39;</span><span class="p">))</span>
                <span class="c1"># NOTE solver can stagnate</span>
                <span class="c1"># s = 0.5*(sign(un_av) + 1.0)</span>
                <span class="c1"># NOTE smooth sign change between [-0.02, 0.02], slow</span>
                <span class="c1"># s = 0.5*tanh(100.0*un_av) + 0.5</span>
                <span class="c1"># uv_up = uv(&#39;-&#39;)*s + uv(&#39;+&#39;)*(1-s)</span>
                <span class="c1"># NOTE mean flux</span>
                <span class="n">uv_up</span> <span class="o">=</span> <span class="n">avg</span><span class="p">(</span><span class="n">uv</span><span class="p">)</span>
                <span class="n">f</span> <span class="o">+=</span> <span class="p">(</span><span class="n">uv_up</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">*</span><span class="n">jump</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">u_test</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">uv_old</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">*</span><span class="bp">self</span><span class="o">.</span><span class="n">normal</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span> <span class="o">+</span>
                      <span class="n">uv_up</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">*</span><span class="n">jump</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">u_test</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">uv_old</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">*</span><span class="bp">self</span><span class="o">.</span><span class="n">normal</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span> <span class="o">+</span>
                      <span class="n">uv_up</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">*</span><span class="n">jump</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">u_test</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">uv_old</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">*</span><span class="bp">self</span><span class="o">.</span><span class="n">normal</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span> <span class="o">+</span>
                      <span class="n">uv_up</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">*</span><span class="n">jump</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">u_test</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">uv_old</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">*</span><span class="bp">self</span><span class="o">.</span><span class="n">normal</span><span class="p">[</span><span class="mi">1</span><span class="p">]))</span><span class="o">*</span><span class="bp">self</span><span class="o">.</span><span class="n">dS</span>
                <span class="c1"># Lax-Friedrichs stabilization</span>
                <span class="k">if</span> <span class="n">uv_lax_friedrichs</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                    <span class="n">gamma</span> <span class="o">=</span> <span class="mf">0.5</span><span class="o">*</span><span class="nb">abs</span><span class="p">(</span><span class="n">un_av</span><span class="p">)</span><span class="o">*</span><span class="n">uv_lax_friedrichs</span>
                    <span class="n">f</span> <span class="o">+=</span> <span class="n">gamma</span><span class="o">*</span><span class="n">dot</span><span class="p">(</span><span class="n">jump</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">u_test</span><span class="p">),</span> <span class="n">jump</span><span class="p">(</span><span class="n">uv</span><span class="p">))</span><span class="o">*</span><span class="bp">self</span><span class="o">.</span><span class="n">dS</span>
                    <span class="k">for</span> <span class="n">bnd_marker</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">boundary_markers</span><span class="p">:</span>
                        <span class="n">funcs</span> <span class="o">=</span> <span class="n">bnd_conditions</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">bnd_marker</span><span class="p">)</span>
                        <span class="n">ds_bnd</span> <span class="o">=</span> <span class="n">ds</span><span class="p">(</span><span class="nb">int</span><span class="p">(</span><span class="n">bnd_marker</span><span class="p">),</span> <span class="n">degree</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">quad_degree</span><span class="p">)</span>
                        <span class="k">if</span> <span class="n">funcs</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                            <span class="c1"># impose impermeability with mirror velocity</span>
                            <span class="n">n</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">normal</span>
                            <span class="n">uv_ext</span> <span class="o">=</span> <span class="n">uv</span> <span class="o">-</span> <span class="mi">2</span><span class="o">*</span><span class="n">dot</span><span class="p">(</span><span class="n">uv</span><span class="p">,</span> <span class="n">n</span><span class="p">)</span><span class="o">*</span><span class="n">n</span>
                            <span class="n">gamma</span> <span class="o">=</span> <span class="mf">0.5</span><span class="o">*</span><span class="nb">abs</span><span class="p">(</span><span class="n">dot</span><span class="p">(</span><span class="n">uv_old</span><span class="p">,</span> <span class="n">n</span><span class="p">))</span><span class="o">*</span><span class="n">uv_lax_friedrichs</span>
                            <span class="n">f</span> <span class="o">+=</span> <span class="n">gamma</span><span class="o">*</span><span class="n">dot</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">u_test</span><span class="p">,</span> <span class="n">uv</span><span class="o">-</span><span class="n">uv_ext</span><span class="p">)</span><span class="o">*</span><span class="n">ds_bnd</span>
            <span class="k">for</span> <span class="n">bnd_marker</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">boundary_markers</span><span class="p">:</span>
                <span class="n">funcs</span> <span class="o">=</span> <span class="n">bnd_conditions</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">bnd_marker</span><span class="p">)</span>
                <span class="n">ds_bnd</span> <span class="o">=</span> <span class="n">ds</span><span class="p">(</span><span class="nb">int</span><span class="p">(</span><span class="n">bnd_marker</span><span class="p">),</span> <span class="n">degree</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">quad_degree</span><span class="p">)</span>
                <span class="k">if</span> <span class="n">funcs</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                    <span class="n">eta_ext</span><span class="p">,</span> <span class="n">uv_ext</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_bnd_functions</span><span class="p">(</span><span class="n">eta</span><span class="p">,</span> <span class="n">uv</span><span class="p">,</span> <span class="n">bnd_marker</span><span class="p">,</span> <span class="n">bnd_conditions</span><span class="p">)</span>
                    <span class="n">eta_ext_old</span><span class="p">,</span> <span class="n">uv_ext_old</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_bnd_functions</span><span class="p">(</span><span class="n">eta_old</span><span class="p">,</span> <span class="n">uv_old</span><span class="p">,</span> <span class="n">bnd_marker</span><span class="p">,</span> <span class="n">bnd_conditions</span><span class="p">)</span>
                    <span class="c1"># Compute linear riemann solution with eta, eta_ext, uv, uv_ext</span>
                    <span class="n">eta_jump</span> <span class="o">=</span> <span class="n">eta_old</span> <span class="o">-</span> <span class="n">eta_ext_old</span>
                    <span class="n">un_rie</span> <span class="o">=</span> <span class="mf">0.5</span><span class="o">*</span><span class="n">inner</span><span class="p">(</span><span class="n">uv_old</span> <span class="o">+</span> <span class="n">uv_ext_old</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">normal</span><span class="p">)</span> <span class="o">+</span> <span class="n">sqrt</span><span class="p">(</span><span class="n">g_grav</span><span class="o">/</span><span class="bp">self</span><span class="o">.</span><span class="n">bathymetry</span><span class="p">)</span><span class="o">*</span><span class="n">eta_jump</span>
                    <span class="n">uv_av</span> <span class="o">=</span> <span class="mf">0.5</span><span class="o">*</span><span class="p">(</span><span class="n">uv_ext</span> <span class="o">+</span> <span class="n">uv</span><span class="p">)</span>
                    <span class="n">f</span> <span class="o">+=</span> <span class="p">(</span><span class="n">uv_av</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">*</span><span class="bp">self</span><span class="o">.</span><span class="n">u_test</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">*</span><span class="n">un_rie</span> <span class="o">+</span>
                          <span class="n">uv_av</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">*</span><span class="bp">self</span><span class="o">.</span><span class="n">u_test</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">*</span><span class="n">un_rie</span><span class="p">)</span><span class="o">*</span><span class="n">ds_bnd</span>
        <span class="k">return</span> <span class="o">-</span><span class="n">f</span></div></div>


<div class="viewcode-block" id="HorizontalViscosityTerm"><a class="viewcode-back" href="../../thetis.html#thetis.shallowwater_eq.HorizontalViscosityTerm">[docs]</a><span class="k">class</span> <span class="nc">HorizontalViscosityTerm</span><span class="p">(</span><span class="n">ShallowWaterMomentumTerm</span><span class="p">):</span>
    <span class="sd">r&quot;&quot;&quot;</span>
<span class="sd">    Viscosity of momentum term</span>

<span class="sd">    If option :attr:`.ModelOptions.include_grad_div_viscosity_term` is ``True``, we</span>
<span class="sd">    use the symmetric viscous stress :math:`\boldsymbol{\tau}_\nu = \nu_h ( \nabla \bar{\textbf{u}} + (\nabla \bar{\textbf{u}})^T )`.</span>
<span class="sd">    Using the symmetric interior penalty method the weak form then reads</span>

<span class="sd">    .. math::</span>
<span class="sd">        \int_\Omega -\nabla \cdot \boldsymbol{\tau}_\nu \cdot \boldsymbol{\psi} dx</span>
<span class="sd">        =&amp; \int_\Omega (\nabla \boldsymbol{\psi}) : \boldsymbol{\tau}_\nu dx \\</span>
<span class="sd">        &amp;- \int_\Gamma \text{jump}(\boldsymbol{\psi} \textbf{n}) \cdot \text{avg}(\boldsymbol{\tau}_\nu) dS</span>
<span class="sd">        - \int_\Gamma \text{avg}(\nu_h)\big(\text{jump}(\bar{\textbf{u}} \textbf{n}) + \text{jump}(\bar{\textbf{u}} \textbf{n})^T\big) \cdot \text{avg}(\nabla \boldsymbol{\psi}) dS \\</span>
<span class="sd">        &amp;+ \int_\Gamma \sigma \text{avg}(\nu_h) \big(\text{jump}(\bar{\textbf{u}} \textbf{n}) + \text{jump}(\bar{\textbf{u}} \textbf{n})^T\big) \cdot \text{jump}(\boldsymbol{\psi} \textbf{n}) dS</span>

<span class="sd">    where :math:`\sigma` is a penalty parameter,</span>
<span class="sd">    see Epshteyn and Riviere (2007).</span>

<span class="sd">    If option :attr:`.ModelOptions.include_grad_div_viscosity_term` is ``False``,</span>
<span class="sd">    we use viscous stress :math:`\boldsymbol{\tau}_\nu = \nu_h \nabla \bar{\textbf{u}}`.</span>
<span class="sd">    In this case the weak form is</span>

<span class="sd">    .. math::</span>
<span class="sd">        \int_\Omega -\nabla \cdot \boldsymbol{\tau}_\nu \cdot \boldsymbol{\psi} dx</span>
<span class="sd">        =&amp; \int_\Omega (\nabla \boldsymbol{\psi}) : \boldsymbol{\tau}_\nu dx \\</span>
<span class="sd">        &amp;- \int_\Gamma \text{jump}(\boldsymbol{\psi} \textbf{n}) \cdot \text{avg}(\boldsymbol{\tau}_\nu) dS</span>
<span class="sd">        - \int_\Gamma \text{avg}(\nu_h)\text{jump}(\bar{\textbf{u}} \textbf{n}) \cdot \text{avg}(\nabla \boldsymbol{\psi}) dS \\</span>
<span class="sd">        &amp;+ \int_\Gamma \sigma \text{avg}(\nu_h) \text{jump}(\bar{\textbf{u}} \textbf{n}) \cdot \text{jump}(\boldsymbol{\psi} \textbf{n}) dS</span>

<span class="sd">    If option :attr:`.ModelOptions.include_grad_depth_viscosity_term` is ``True``, we also include</span>
<span class="sd">    the term</span>

<span class="sd">    .. math::</span>
<span class="sd">        \boldsymbol{\tau}_{\nabla H} = - \frac{\nu_h \nabla(H)}{H} \cdot ( \nabla \bar{\textbf{u}} + (\nabla \bar{\textbf{u}})^T )</span>

<span class="sd">    as a source term.</span>

<span class="sd">    Epshteyn and Riviere (2007). Estimation of penalty parameters for symmetric</span>
<span class="sd">    interior penalty Galerkin methods. Journal of Computational and Applied</span>
<span class="sd">    Mathematics, 206(2):843-872. http://dx.doi.org/10.1016/j.cam.2006.08.029</span>

<span class="sd">    .. note ::</span>
<span class="sd">        Note the minus sign due to :class:`.equation.Term` sign convention</span>
<span class="sd">    &quot;&quot;&quot;</span>
<div class="viewcode-block" id="HorizontalViscosityTerm.residual"><a class="viewcode-back" href="../../thetis.html#thetis.shallowwater_eq.HorizontalViscosityTerm.residual">[docs]</a>    <span class="k">def</span> <span class="nf">residual</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">uv</span><span class="p">,</span> <span class="n">eta</span><span class="p">,</span> <span class="n">uv_old</span><span class="p">,</span> <span class="n">eta_old</span><span class="p">,</span> <span class="n">fields</span><span class="p">,</span> <span class="n">fields_old</span><span class="p">,</span> <span class="n">bnd_conditions</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="n">total_h</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_total_depth</span><span class="p">(</span><span class="n">eta_old</span><span class="p">)</span>

        <span class="n">nu</span> <span class="o">=</span> <span class="n">fields_old</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;viscosity_h&#39;</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">nu</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">return</span> <span class="mi">0</span>

        <span class="n">n</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">normal</span>
        <span class="n">h</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">cellsize</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">include_grad_div_viscosity_term</span><span class="p">:</span>
            <span class="n">stress</span> <span class="o">=</span> <span class="n">nu</span><span class="o">*</span><span class="mf">2.</span><span class="o">*</span><span class="n">sym</span><span class="p">(</span><span class="n">grad</span><span class="p">(</span><span class="n">uv</span><span class="p">))</span>
            <span class="n">stress_jump</span> <span class="o">=</span> <span class="n">avg</span><span class="p">(</span><span class="n">nu</span><span class="p">)</span><span class="o">*</span><span class="mf">2.</span><span class="o">*</span><span class="n">sym</span><span class="p">(</span><span class="n">tensor_jump</span><span class="p">(</span><span class="n">uv</span><span class="p">,</span> <span class="n">n</span><span class="p">))</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">stress</span> <span class="o">=</span> <span class="n">nu</span><span class="o">*</span><span class="n">grad</span><span class="p">(</span><span class="n">uv</span><span class="p">)</span>
            <span class="n">stress_jump</span> <span class="o">=</span> <span class="n">avg</span><span class="p">(</span><span class="n">nu</span><span class="p">)</span><span class="o">*</span><span class="n">tensor_jump</span><span class="p">(</span><span class="n">uv</span><span class="p">,</span> <span class="n">n</span><span class="p">)</span>

        <span class="n">f</span> <span class="o">=</span> <span class="n">inner</span><span class="p">(</span><span class="n">grad</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">u_test</span><span class="p">),</span> <span class="n">stress</span><span class="p">)</span><span class="o">*</span><span class="bp">self</span><span class="o">.</span><span class="n">dx</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">u_is_dg</span><span class="p">:</span>
            <span class="c1"># from Epshteyn et al. 2007 (http://dx.doi.org/10.1016/j.cam.2006.08.029)</span>
            <span class="c1"># the scheme is stable for alpha &gt; 3*X*p*(p+1)*cot(theta), where X is the</span>
            <span class="c1"># maximum ratio of viscosity within a triangle, p the degree, and theta</span>
            <span class="c1"># with X=2, theta=6: cot(theta)~10, 3*X*cot(theta)~60</span>
            <span class="n">p</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">u_space</span><span class="o">.</span><span class="n">ufl_element</span><span class="p">()</span><span class="o">.</span><span class="n">degree</span><span class="p">()</span>
            <span class="n">alpha</span> <span class="o">=</span> <span class="mf">5.</span><span class="o">*</span><span class="n">p</span><span class="o">*</span><span class="p">(</span><span class="n">p</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">p</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                <span class="n">alpha</span> <span class="o">=</span> <span class="mf">1.5</span>
            <span class="n">f</span> <span class="o">+=</span> <span class="p">(</span>
                <span class="o">+</span> <span class="n">alpha</span><span class="o">/</span><span class="n">avg</span><span class="p">(</span><span class="n">h</span><span class="p">)</span><span class="o">*</span><span class="n">inner</span><span class="p">(</span><span class="n">tensor_jump</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">u_test</span><span class="p">,</span> <span class="n">n</span><span class="p">),</span> <span class="n">stress_jump</span><span class="p">)</span><span class="o">*</span><span class="bp">self</span><span class="o">.</span><span class="n">dS</span>
                <span class="o">-</span> <span class="n">inner</span><span class="p">(</span><span class="n">avg</span><span class="p">(</span><span class="n">grad</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">u_test</span><span class="p">)),</span> <span class="n">stress_jump</span><span class="p">)</span><span class="o">*</span><span class="bp">self</span><span class="o">.</span><span class="n">dS</span>
                <span class="o">-</span> <span class="n">inner</span><span class="p">(</span><span class="n">tensor_jump</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">u_test</span><span class="p">,</span> <span class="n">n</span><span class="p">),</span> <span class="n">avg</span><span class="p">(</span><span class="n">stress</span><span class="p">))</span><span class="o">*</span><span class="bp">self</span><span class="o">.</span><span class="n">dS</span>
            <span class="p">)</span>

            <span class="c1"># Dirichlet bcs only for DG</span>
            <span class="k">for</span> <span class="n">bnd_marker</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">boundary_markers</span><span class="p">:</span>
                <span class="n">funcs</span> <span class="o">=</span> <span class="n">bnd_conditions</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">bnd_marker</span><span class="p">)</span>
                <span class="n">ds_bnd</span> <span class="o">=</span> <span class="n">ds</span><span class="p">(</span><span class="nb">int</span><span class="p">(</span><span class="n">bnd_marker</span><span class="p">),</span> <span class="n">degree</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">quad_degree</span><span class="p">)</span>
                <span class="k">if</span> <span class="n">funcs</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                    <span class="k">if</span> <span class="s1">&#39;un&#39;</span> <span class="ow">in</span> <span class="n">funcs</span><span class="p">:</span>
                        <span class="n">delta_uv</span> <span class="o">=</span> <span class="p">(</span><span class="n">dot</span><span class="p">(</span><span class="n">uv</span><span class="p">,</span> <span class="n">n</span><span class="p">)</span> <span class="o">-</span> <span class="n">funcs</span><span class="p">[</span><span class="s1">&#39;un&#39;</span><span class="p">])</span><span class="o">*</span><span class="n">n</span>
                    <span class="k">else</span><span class="p">:</span>
                        <span class="n">eta_ext</span><span class="p">,</span> <span class="n">uv_ext</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_bnd_functions</span><span class="p">(</span><span class="n">eta</span><span class="p">,</span> <span class="n">uv</span><span class="p">,</span> <span class="n">bnd_marker</span><span class="p">,</span> <span class="n">bnd_conditions</span><span class="p">)</span>
                        <span class="k">if</span> <span class="n">uv_ext</span> <span class="ow">is</span> <span class="n">uv</span><span class="p">:</span>
                            <span class="k">continue</span>
                        <span class="n">delta_uv</span> <span class="o">=</span> <span class="n">uv</span> <span class="o">-</span> <span class="n">uv_ext</span>

                    <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">include_grad_div_viscosity_term</span><span class="p">:</span>
                        <span class="n">stress_jump</span> <span class="o">=</span> <span class="n">nu</span><span class="o">*</span><span class="mf">2.</span><span class="o">*</span><span class="n">sym</span><span class="p">(</span><span class="n">outer</span><span class="p">(</span><span class="n">delta_uv</span><span class="p">,</span> <span class="n">n</span><span class="p">))</span>
                    <span class="k">else</span><span class="p">:</span>
                        <span class="n">stress_jump</span> <span class="o">=</span> <span class="n">nu</span><span class="o">*</span><span class="n">outer</span><span class="p">(</span><span class="n">delta_uv</span><span class="p">,</span> <span class="n">n</span><span class="p">)</span>

                    <span class="n">f</span> <span class="o">+=</span> <span class="p">(</span>
                        <span class="n">alpha</span><span class="o">/</span><span class="n">h</span><span class="o">*</span><span class="n">inner</span><span class="p">(</span><span class="n">outer</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">u_test</span><span class="p">,</span> <span class="n">n</span><span class="p">),</span> <span class="n">stress_jump</span><span class="p">)</span><span class="o">*</span><span class="n">ds_bnd</span>
                        <span class="o">-</span> <span class="n">inner</span><span class="p">(</span><span class="n">grad</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">u_test</span><span class="p">),</span> <span class="n">stress_jump</span><span class="p">)</span><span class="o">*</span><span class="n">ds_bnd</span>
                        <span class="o">-</span> <span class="n">inner</span><span class="p">(</span><span class="n">outer</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">u_test</span><span class="p">,</span> <span class="n">n</span><span class="p">),</span> <span class="n">stress</span><span class="p">)</span><span class="o">*</span><span class="n">ds_bnd</span>
                    <span class="p">)</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">include_grad_depth_viscosity_term</span><span class="p">:</span>
            <span class="n">f</span> <span class="o">+=</span> <span class="o">-</span><span class="n">dot</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">u_test</span><span class="p">,</span> <span class="n">dot</span><span class="p">(</span><span class="n">grad</span><span class="p">(</span><span class="n">total_h</span><span class="p">)</span><span class="o">/</span><span class="n">total_h</span><span class="p">,</span> <span class="n">stress</span><span class="p">))</span><span class="o">*</span><span class="bp">self</span><span class="o">.</span><span class="n">dx</span>

        <span class="k">return</span> <span class="o">-</span><span class="n">f</span></div></div>


<div class="viewcode-block" id="CoriolisTerm"><a class="viewcode-back" href="../../thetis.html#thetis.shallowwater_eq.CoriolisTerm">[docs]</a><span class="k">class</span> <span class="nc">CoriolisTerm</span><span class="p">(</span><span class="n">ShallowWaterMomentumTerm</span><span class="p">):</span>
    <span class="sd">r&quot;&quot;&quot;</span>
<span class="sd">    Coriolis term, :math:`f\textbf{e}_z\wedge \bar{\textbf{u}}`</span>
<span class="sd">    &quot;&quot;&quot;</span>
<div class="viewcode-block" id="CoriolisTerm.residual"><a class="viewcode-back" href="../../thetis.html#thetis.shallowwater_eq.CoriolisTerm.residual">[docs]</a>    <span class="k">def</span> <span class="nf">residual</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">uv</span><span class="p">,</span> <span class="n">eta</span><span class="p">,</span> <span class="n">uv_old</span><span class="p">,</span> <span class="n">eta_old</span><span class="p">,</span> <span class="n">fields</span><span class="p">,</span> <span class="n">fields_old</span><span class="p">,</span> <span class="n">bnd_conditions</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="n">coriolis</span> <span class="o">=</span> <span class="n">fields_old</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;coriolis&#39;</span><span class="p">)</span>
        <span class="n">f</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="k">if</span> <span class="n">coriolis</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">f</span> <span class="o">+=</span> <span class="n">coriolis</span><span class="o">*</span><span class="p">(</span><span class="o">-</span><span class="n">uv</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">*</span><span class="bp">self</span><span class="o">.</span><span class="n">u_test</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">+</span> <span class="n">uv</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">*</span><span class="bp">self</span><span class="o">.</span><span class="n">u_test</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span><span class="o">*</span><span class="bp">self</span><span class="o">.</span><span class="n">dx</span>
        <span class="k">return</span> <span class="o">-</span><span class="n">f</span></div></div>


<div class="viewcode-block" id="WindStressTerm"><a class="viewcode-back" href="../../thetis.html#thetis.shallowwater_eq.WindStressTerm">[docs]</a><span class="k">class</span> <span class="nc">WindStressTerm</span><span class="p">(</span><span class="n">ShallowWaterMomentumTerm</span><span class="p">):</span>
    <span class="sd">r&quot;&quot;&quot;</span>
<span class="sd">    Wind stress term, :math:`-\tau_w/(H \rho_0)`</span>

<span class="sd">    Here :math:`\tau_w` is a user-defined wind stress :class:`Function`.</span>
<span class="sd">    &quot;&quot;&quot;</span>
<div class="viewcode-block" id="WindStressTerm.residual"><a class="viewcode-back" href="../../thetis.html#thetis.shallowwater_eq.WindStressTerm.residual">[docs]</a>    <span class="k">def</span> <span class="nf">residual</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">uv</span><span class="p">,</span> <span class="n">eta</span><span class="p">,</span> <span class="n">uv_old</span><span class="p">,</span> <span class="n">eta_old</span><span class="p">,</span> <span class="n">fields</span><span class="p">,</span> <span class="n">fields_old</span><span class="p">,</span> <span class="n">bnd_conditions</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="n">wind_stress</span> <span class="o">=</span> <span class="n">fields_old</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;wind_stress&#39;</span><span class="p">)</span>
        <span class="n">total_h</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_total_depth</span><span class="p">(</span><span class="n">eta_old</span><span class="p">)</span>
        <span class="n">f</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="k">if</span> <span class="n">wind_stress</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">f</span> <span class="o">+=</span> <span class="o">-</span><span class="n">dot</span><span class="p">(</span><span class="n">wind_stress</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">u_test</span><span class="p">)</span><span class="o">/</span><span class="n">total_h</span><span class="o">/</span><span class="n">rho_0</span><span class="o">*</span><span class="bp">self</span><span class="o">.</span><span class="n">dx</span>
        <span class="k">return</span> <span class="o">-</span><span class="n">f</span></div></div>


<div class="viewcode-block" id="QuadraticDragTerm"><a class="viewcode-back" href="../../thetis.html#thetis.shallowwater_eq.QuadraticDragTerm">[docs]</a><span class="k">class</span> <span class="nc">QuadraticDragTerm</span><span class="p">(</span><span class="n">ShallowWaterMomentumTerm</span><span class="p">):</span>
    <span class="sd">r&quot;&quot;&quot;</span>
<span class="sd">    Quadratic Manning bottom friction term</span>
<span class="sd">    :math:`C_D \| \bar{\textbf{u}} \| \bar{\textbf{u}}`</span>

<span class="sd">    where the drag term is computed with the Manning formula</span>

<span class="sd">    .. math::</span>
<span class="sd">        C_D = g \frac{\mu^2}{H^{1/3}}</span>

<span class="sd">    if the Manning coefficient :math:`\mu` is defined (see field :attr:`mu_manning`).</span>
<span class="sd">    Otherwise :math:`C_D` is taken as a constant (see field :attr:`quadratic_drag`).</span>
<span class="sd">    &quot;&quot;&quot;</span>
<div class="viewcode-block" id="QuadraticDragTerm.residual"><a class="viewcode-back" href="../../thetis.html#thetis.shallowwater_eq.QuadraticDragTerm.residual">[docs]</a>    <span class="k">def</span> <span class="nf">residual</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">uv</span><span class="p">,</span> <span class="n">eta</span><span class="p">,</span> <span class="n">uv_old</span><span class="p">,</span> <span class="n">eta_old</span><span class="p">,</span> <span class="n">fields</span><span class="p">,</span> <span class="n">fields_old</span><span class="p">,</span> <span class="n">bnd_conditions</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="n">total_h</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_total_depth</span><span class="p">(</span><span class="n">eta_old</span><span class="p">)</span>
        <span class="n">mu_manning</span> <span class="o">=</span> <span class="n">fields_old</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;mu_manning&#39;</span><span class="p">)</span>
        <span class="n">C_D</span> <span class="o">=</span> <span class="n">fields_old</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;quadratic_drag&#39;</span><span class="p">)</span>
        <span class="n">f</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="k">if</span> <span class="n">mu_manning</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">C_D</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="s1">&#39;Cannot set both dimensionless and Manning drag parameter&#39;</span><span class="p">)</span>
            <span class="n">C_D</span> <span class="o">=</span> <span class="n">g_grav</span> <span class="o">*</span> <span class="n">mu_manning</span><span class="o">**</span><span class="mi">2</span> <span class="o">/</span> <span class="n">total_h</span><span class="o">**</span><span class="p">(</span><span class="mf">1.</span><span class="o">/</span><span class="mf">3.</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">C_D</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">f</span> <span class="o">+=</span> <span class="n">C_D</span> <span class="o">*</span> <span class="n">sqrt</span><span class="p">(</span><span class="n">dot</span><span class="p">(</span><span class="n">uv_old</span><span class="p">,</span> <span class="n">uv_old</span><span class="p">))</span> <span class="o">*</span> <span class="n">inner</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">u_test</span><span class="p">,</span> <span class="n">uv</span><span class="p">)</span> <span class="o">/</span> <span class="n">total_h</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">dx</span>
        <span class="k">return</span> <span class="o">-</span><span class="n">f</span></div></div>


<div class="viewcode-block" id="LinearDragTerm"><a class="viewcode-back" href="../../thetis.html#thetis.shallowwater_eq.LinearDragTerm">[docs]</a><span class="k">class</span> <span class="nc">LinearDragTerm</span><span class="p">(</span><span class="n">ShallowWaterMomentumTerm</span><span class="p">):</span>
    <span class="sd">r&quot;&quot;&quot;</span>
<span class="sd">    Linear friction term, :math:`C \bar{\textbf{u}}`</span>

<span class="sd">    Here :math:`C` is a user-defined drag coefficient.</span>
<span class="sd">    &quot;&quot;&quot;</span>
<div class="viewcode-block" id="LinearDragTerm.residual"><a class="viewcode-back" href="../../thetis.html#thetis.shallowwater_eq.LinearDragTerm.residual">[docs]</a>    <span class="k">def</span> <span class="nf">residual</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">uv</span><span class="p">,</span> <span class="n">eta</span><span class="p">,</span> <span class="n">uv_old</span><span class="p">,</span> <span class="n">eta_old</span><span class="p">,</span> <span class="n">fields</span><span class="p">,</span> <span class="n">fields_old</span><span class="p">,</span> <span class="n">bnd_conditions</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="n">linear_drag</span> <span class="o">=</span> <span class="n">fields_old</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;linear_drag&#39;</span><span class="p">)</span>
        <span class="n">f</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="k">if</span> <span class="n">linear_drag</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">bottom_fri</span> <span class="o">=</span> <span class="n">linear_drag</span><span class="o">*</span><span class="n">inner</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">u_test</span><span class="p">,</span> <span class="n">uv</span><span class="p">)</span><span class="o">*</span><span class="bp">self</span><span class="o">.</span><span class="n">dx</span>
            <span class="n">f</span> <span class="o">+=</span> <span class="n">bottom_fri</span>
        <span class="k">return</span> <span class="o">-</span><span class="n">f</span></div></div>


<div class="viewcode-block" id="BottomDrag3DTerm"><a class="viewcode-back" href="../../thetis.html#thetis.shallowwater_eq.BottomDrag3DTerm">[docs]</a><span class="k">class</span> <span class="nc">BottomDrag3DTerm</span><span class="p">(</span><span class="n">ShallowWaterMomentumTerm</span><span class="p">):</span>
    <span class="sd">r&quot;&quot;&quot;</span>
<span class="sd">    Bottom drag term consistent with the 3D mode,</span>
<span class="sd">    :math:`C_D \| \textbf{u}_b \| \textbf{u}_b`</span>

<span class="sd">    Here :math:`\textbf{u}_b` is the bottom velocity used in the 3D mode, and</span>
<span class="sd">    :math:`C_D` the corresponding bottom drag.</span>
<span class="sd">    These fields are computed in the 3D model.</span>
<span class="sd">    &quot;&quot;&quot;</span>
<div class="viewcode-block" id="BottomDrag3DTerm.residual"><a class="viewcode-back" href="../../thetis.html#thetis.shallowwater_eq.BottomDrag3DTerm.residual">[docs]</a>    <span class="k">def</span> <span class="nf">residual</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">uv</span><span class="p">,</span> <span class="n">eta</span><span class="p">,</span> <span class="n">uv_old</span><span class="p">,</span> <span class="n">eta_old</span><span class="p">,</span> <span class="n">fields</span><span class="p">,</span> <span class="n">fields_old</span><span class="p">,</span> <span class="n">bnd_conditions</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="n">total_h</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_total_depth</span><span class="p">(</span><span class="n">eta_old</span><span class="p">)</span>
        <span class="n">bottom_drag</span> <span class="o">=</span> <span class="n">fields_old</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;bottom_drag&#39;</span><span class="p">)</span>
        <span class="n">uv_bottom</span> <span class="o">=</span> <span class="n">fields_old</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;uv_bottom&#39;</span><span class="p">)</span>
        <span class="n">f</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="k">if</span> <span class="n">bottom_drag</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> <span class="n">uv_bottom</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">uvb_mag</span> <span class="o">=</span> <span class="n">sqrt</span><span class="p">(</span><span class="n">uv_bottom</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">**</span><span class="mi">2</span> <span class="o">+</span> <span class="n">uv_bottom</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span>
            <span class="n">stress</span> <span class="o">=</span> <span class="n">bottom_drag</span><span class="o">*</span><span class="n">uvb_mag</span><span class="o">*</span><span class="n">uv_bottom</span><span class="o">/</span><span class="n">total_h</span>
            <span class="n">bot_friction</span> <span class="o">=</span> <span class="n">dot</span><span class="p">(</span><span class="n">stress</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">u_test</span><span class="p">)</span><span class="o">*</span><span class="bp">self</span><span class="o">.</span><span class="n">dx</span>
            <span class="n">f</span> <span class="o">+=</span> <span class="n">bot_friction</span>
        <span class="k">return</span> <span class="o">-</span><span class="n">f</span></div></div>


<div class="viewcode-block" id="InternalPressureGradientTerm"><a class="viewcode-back" href="../../thetis.html#thetis.shallowwater_eq.InternalPressureGradientTerm">[docs]</a><span class="k">class</span> <span class="nc">InternalPressureGradientTerm</span><span class="p">(</span><span class="n">ShallowWaterMomentumTerm</span><span class="p">):</span>
    <span class="sd">r&quot;&quot;&quot;</span>
<span class="sd">    Internal pressure gradient term</span>

<span class="sd">    .. math::</span>
<span class="sd">        F_{IPG} = \frac{g}{H} \int_{-h}^{\eta} (\nabla r) dz,</span>

<span class="sd">    where :math:`r` is the baroc_head.</span>
<span class="sd">    Let :math:`s` denote :math:`r/H`. We can then write</span>

<span class="sd">    .. math::</span>
<span class="sd">        F_{IPG} = g\nabla(\bar{s} H) - g\nabla \Big(\frac{1}{H} \Big) H^2\bar{s} - g s_{bot}\nabla h</span>

<span class="sd">    where :math:`\bar{s},s_{bot}` are the depth average and bottom value of</span>
<span class="sd">    :math:`s`. This term is implemented as a source term not integrated by</span>
<span class="sd">    parts.</span>
<span class="sd">    &quot;&quot;&quot;</span>
<div class="viewcode-block" id="InternalPressureGradientTerm.residual"><a class="viewcode-back" href="../../thetis.html#thetis.shallowwater_eq.InternalPressureGradientTerm.residual">[docs]</a>    <span class="k">def</span> <span class="nf">residual</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">uv</span><span class="p">,</span> <span class="n">eta</span><span class="p">,</span> <span class="n">uv_old</span><span class="p">,</span> <span class="n">eta_old</span><span class="p">,</span> <span class="n">fields</span><span class="p">,</span> <span class="n">fields_old</span><span class="p">,</span> <span class="n">bnd_conditions</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="n">baroc_head</span> <span class="o">=</span> <span class="n">fields_old</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;baroc_head&#39;</span><span class="p">)</span>
        <span class="n">baroc_head_bot</span> <span class="o">=</span> <span class="n">fields_old</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;baroc_head_bot&#39;</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">baroc_head</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">return</span> <span class="mi">0</span>

        <span class="n">depth_old</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_total_depth</span><span class="p">(</span><span class="n">eta_old</span><span class="p">)</span>
        <span class="n">depth</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_total_depth</span><span class="p">(</span><span class="n">eta</span><span class="p">)</span>
        <span class="n">source</span> <span class="o">=</span> <span class="n">baroc_head</span><span class="o">*</span><span class="n">depth</span>
        <span class="n">by_parts</span> <span class="o">=</span> <span class="kc">False</span>  <span class="c1"># FIXME breaks p0 elements</span>

        <span class="n">f</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="k">if</span> <span class="n">by_parts</span><span class="p">:</span>
            <span class="n">f</span> <span class="o">=</span> <span class="o">-</span><span class="n">g_grav</span><span class="o">*</span><span class="n">source</span><span class="o">*</span><span class="n">nabla_div</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">u_test</span><span class="p">)</span><span class="o">*</span><span class="bp">self</span><span class="o">.</span><span class="n">dx</span>
            <span class="n">head_star</span> <span class="o">=</span> <span class="n">avg</span><span class="p">(</span><span class="n">source</span><span class="p">)</span>
            <span class="n">f</span> <span class="o">+=</span> <span class="n">g_grav</span><span class="o">*</span><span class="n">head_star</span><span class="o">*</span><span class="n">jump</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">u_test</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">normal</span><span class="p">)</span><span class="o">*</span><span class="bp">self</span><span class="o">.</span><span class="n">dS</span>
            <span class="k">for</span> <span class="n">bnd_marker</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">boundary_markers</span><span class="p">:</span>
                <span class="n">ds_bnd</span> <span class="o">=</span> <span class="n">ds</span><span class="p">(</span><span class="nb">int</span><span class="p">(</span><span class="n">bnd_marker</span><span class="p">),</span> <span class="n">degree</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">quad_degree</span><span class="p">)</span>
                <span class="c1"># use internal value</span>
                <span class="n">head_rie</span> <span class="o">=</span> <span class="n">source</span>
                <span class="n">f</span> <span class="o">+=</span> <span class="n">g_grav</span><span class="o">*</span><span class="n">head_rie</span><span class="o">*</span><span class="n">dot</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">u_test</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">normal</span><span class="p">)</span><span class="o">*</span><span class="n">ds_bnd</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">f</span> <span class="o">=</span> <span class="n">g_grav</span><span class="o">*</span><span class="n">inner</span><span class="p">(</span><span class="n">grad</span><span class="p">(</span><span class="n">source</span><span class="p">),</span> <span class="bp">self</span><span class="o">.</span><span class="n">u_test</span><span class="p">)</span><span class="o">*</span><span class="bp">self</span><span class="o">.</span><span class="n">dx</span>
        <span class="n">f</span> <span class="o">+=</span> <span class="o">-</span><span class="n">g_grav</span><span class="o">*</span><span class="n">inner</span><span class="p">(</span><span class="n">grad</span><span class="p">(</span><span class="mi">1</span><span class="o">/</span><span class="n">depth_old</span><span class="p">)</span><span class="o">*</span><span class="n">depth_old</span><span class="o">*</span><span class="n">source</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">u_test</span><span class="p">)</span><span class="o">*</span><span class="bp">self</span><span class="o">.</span><span class="n">dx</span>
        <span class="n">f</span> <span class="o">+=</span> <span class="o">-</span><span class="n">g_grav</span><span class="o">*</span><span class="n">inner</span><span class="p">(</span><span class="n">grad</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">bathymetry</span><span class="p">)</span><span class="o">*</span><span class="n">baroc_head_bot</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">u_test</span><span class="p">)</span><span class="o">*</span><span class="bp">self</span><span class="o">.</span><span class="n">dx</span>
        <span class="k">return</span> <span class="o">-</span><span class="n">f</span></div></div>


<div class="viewcode-block" id="MomentumSourceTerm"><a class="viewcode-back" href="../../thetis.html#thetis.shallowwater_eq.MomentumSourceTerm">[docs]</a><span class="k">class</span> <span class="nc">MomentumSourceTerm</span><span class="p">(</span><span class="n">ShallowWaterMomentumTerm</span><span class="p">):</span>
    <span class="sd">r&quot;&quot;&quot;</span>
<span class="sd">    Generic source term in the shallow water momentum equation</span>

<span class="sd">    The weak form reads</span>

<span class="sd">    .. math::</span>
<span class="sd">        F_s = \int_\Omega \boldsymbol{\tau} \cdot \boldsymbol{\psi} dx</span>

<span class="sd">    where :math:`\boldsymbol{\tau}` is a user defined vector valued :class:`Function`.</span>

<span class="sd">    .. note ::</span>
<span class="sd">        Due to the sign convention of :class:`.equation.Term`, this term is assembled to the left hand side of the equation</span>
<span class="sd">    &quot;&quot;&quot;</span>
<div class="viewcode-block" id="MomentumSourceTerm.residual"><a class="viewcode-back" href="../../thetis.html#thetis.shallowwater_eq.MomentumSourceTerm.residual">[docs]</a>    <span class="k">def</span> <span class="nf">residual</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">uv</span><span class="p">,</span> <span class="n">eta</span><span class="p">,</span> <span class="n">uv_old</span><span class="p">,</span> <span class="n">eta_old</span><span class="p">,</span> <span class="n">fields</span><span class="p">,</span> <span class="n">fields_old</span><span class="p">,</span> <span class="n">bnd_conditions</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="n">f</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="n">uv_source</span> <span class="o">=</span> <span class="n">fields_old</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;uv_source&#39;</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">uv_source</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">f</span> <span class="o">+=</span> <span class="o">-</span><span class="n">inner</span><span class="p">(</span><span class="n">uv_source</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">u_test</span><span class="p">)</span><span class="o">*</span><span class="bp">self</span><span class="o">.</span><span class="n">dx</span>
        <span class="k">return</span> <span class="o">-</span><span class="n">f</span></div></div>


<div class="viewcode-block" id="ContinuitySourceTerm"><a class="viewcode-back" href="../../thetis.html#thetis.shallowwater_eq.ContinuitySourceTerm">[docs]</a><span class="k">class</span> <span class="nc">ContinuitySourceTerm</span><span class="p">(</span><span class="n">ShallowWaterContinuityTerm</span><span class="p">):</span>
    <span class="sd">r&quot;&quot;&quot;</span>
<span class="sd">    Generic source term in the depth-averaged continuity equation</span>

<span class="sd">    The weak form reads</span>

<span class="sd">    .. math::</span>
<span class="sd">        F_s = \int_\Omega S \phi dx</span>

<span class="sd">    where :math:`S` is a user defined scalar :class:`Function`.</span>

<span class="sd">    .. note ::</span>
<span class="sd">        Due to the sign convention of :class:`.equation.Term`, this term is assembled to the left hand side of the equation</span>
<span class="sd">    &quot;&quot;&quot;</span>
<div class="viewcode-block" id="ContinuitySourceTerm.residual"><a class="viewcode-back" href="../../thetis.html#thetis.shallowwater_eq.ContinuitySourceTerm.residual">[docs]</a>    <span class="k">def</span> <span class="nf">residual</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">uv</span><span class="p">,</span> <span class="n">eta</span><span class="p">,</span> <span class="n">uv_old</span><span class="p">,</span> <span class="n">eta_old</span><span class="p">,</span> <span class="n">fields</span><span class="p">,</span> <span class="n">fields_old</span><span class="p">,</span> <span class="n">bnd_conditions</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="n">f</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="n">elev_source</span> <span class="o">=</span> <span class="n">fields_old</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;elev_source&#39;</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">elev_source</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">f</span> <span class="o">+=</span> <span class="o">-</span><span class="n">inner</span><span class="p">(</span><span class="n">elev_source</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">eta_test</span><span class="p">)</span><span class="o">*</span><span class="bp">self</span><span class="o">.</span><span class="n">dx</span>
        <span class="k">return</span> <span class="o">-</span><span class="n">f</span></div></div>


<div class="viewcode-block" id="BaseShallowWaterEquation"><a class="viewcode-back" href="../../thetis.html#thetis.shallowwater_eq.BaseShallowWaterEquation">[docs]</a><span class="k">class</span> <span class="nc">BaseShallowWaterEquation</span><span class="p">(</span><span class="n">Equation</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Abstract base class for ShallowWaterEquations, ShallowWaterMomentumEquation</span>
<span class="sd">    and FreeSurfaceEquation.</span>

<span class="sd">    Provides common functionality to compute time steps and add either momentum</span>
<span class="sd">    or continuity terms.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">function_space</span><span class="p">,</span>
                 <span class="n">bathymetry</span><span class="p">,</span>
                 <span class="n">nonlin</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
        <span class="nb">super</span><span class="p">(</span><span class="n">BaseShallowWaterEquation</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="n">__init__</span><span class="p">(</span><span class="n">function_space</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">bathymetry</span> <span class="o">=</span> <span class="n">bathymetry</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">nonlin</span> <span class="o">=</span> <span class="n">nonlin</span>

<div class="viewcode-block" id="BaseShallowWaterEquation.add_momentum_terms"><a class="viewcode-back" href="../../thetis.html#thetis.shallowwater_eq.BaseShallowWaterEquation.add_momentum_terms">[docs]</a>    <span class="k">def</span> <span class="nf">add_momentum_terms</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">add_term</span><span class="p">(</span><span class="n">ExternalPressureGradientTerm</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">),</span> <span class="s1">&#39;implicit&#39;</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">add_term</span><span class="p">(</span><span class="n">HorizontalAdvectionTerm</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">),</span> <span class="s1">&#39;explicit&#39;</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">add_term</span><span class="p">(</span><span class="n">HorizontalViscosityTerm</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">),</span> <span class="s1">&#39;explicit&#39;</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">add_term</span><span class="p">(</span><span class="n">CoriolisTerm</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">),</span> <span class="s1">&#39;explicit&#39;</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">add_term</span><span class="p">(</span><span class="n">WindStressTerm</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">),</span> <span class="s1">&#39;source&#39;</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">add_term</span><span class="p">(</span><span class="n">QuadraticDragTerm</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">),</span> <span class="s1">&#39;explicit&#39;</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">add_term</span><span class="p">(</span><span class="n">LinearDragTerm</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">),</span> <span class="s1">&#39;explicit&#39;</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">add_term</span><span class="p">(</span><span class="n">BottomDrag3DTerm</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">),</span> <span class="s1">&#39;source&#39;</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">add_term</span><span class="p">(</span><span class="n">InternalPressureGradientTerm</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">),</span> <span class="s1">&#39;source&#39;</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">add_term</span><span class="p">(</span><span class="n">MomentumSourceTerm</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">),</span> <span class="s1">&#39;source&#39;</span><span class="p">)</span></div>

<div class="viewcode-block" id="BaseShallowWaterEquation.add_continuity_terms"><a class="viewcode-back" href="../../thetis.html#thetis.shallowwater_eq.BaseShallowWaterEquation.add_continuity_terms">[docs]</a>    <span class="k">def</span> <span class="nf">add_continuity_terms</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">add_term</span><span class="p">(</span><span class="n">HUDivTerm</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">),</span> <span class="s1">&#39;implicit&#39;</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">add_term</span><span class="p">(</span><span class="n">ContinuitySourceTerm</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">),</span> <span class="s1">&#39;source&#39;</span><span class="p">)</span></div>

<div class="viewcode-block" id="BaseShallowWaterEquation.residual_uv_eta"><a class="viewcode-back" href="../../thetis.html#thetis.shallowwater_eq.BaseShallowWaterEquation.residual_uv_eta">[docs]</a>    <span class="k">def</span> <span class="nf">residual_uv_eta</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">label</span><span class="p">,</span> <span class="n">uv</span><span class="p">,</span> <span class="n">eta</span><span class="p">,</span> <span class="n">uv_old</span><span class="p">,</span> <span class="n">eta_old</span><span class="p">,</span> <span class="n">fields</span><span class="p">,</span> <span class="n">fields_old</span><span class="p">,</span> <span class="n">bnd_conditions</span><span class="p">):</span>
        <span class="n">f</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="k">for</span> <span class="n">term</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">select_terms</span><span class="p">(</span><span class="n">label</span><span class="p">):</span>
            <span class="n">f</span> <span class="o">+=</span> <span class="n">term</span><span class="o">.</span><span class="n">residual</span><span class="p">(</span><span class="n">uv</span><span class="p">,</span> <span class="n">eta</span><span class="p">,</span> <span class="n">uv_old</span><span class="p">,</span> <span class="n">eta_old</span><span class="p">,</span> <span class="n">fields</span><span class="p">,</span> <span class="n">fields_old</span><span class="p">,</span> <span class="n">bnd_conditions</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">f</span></div></div>


<div class="viewcode-block" id="ShallowWaterEquations"><a class="viewcode-back" href="../../thetis.html#thetis.shallowwater_eq.ShallowWaterEquations">[docs]</a><span class="k">class</span> <span class="nc">ShallowWaterEquations</span><span class="p">(</span><span class="n">BaseShallowWaterEquation</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    2D depth-averaged shallow water equations in non-conservative form.</span>

<span class="sd">    This defines the full 2D SWE equations :eq:`swe_freesurf` -</span>
<span class="sd">    :eq:`swe_momentum`.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">function_space</span><span class="p">,</span>
                 <span class="n">bathymetry</span><span class="p">,</span>
                 <span class="n">nonlin</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
                 <span class="n">include_grad_div_viscosity_term</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
                 <span class="n">include_grad_depth_viscosity_term</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        :arg function_space: Mixed function space where the solution belongs</span>
<span class="sd">        :arg bathymetry: bathymetry of the domain</span>
<span class="sd">        :type bathymetry: :class:`Function` or :class:`Constant`</span>
<span class="sd">        :kwarg bool nonlin: If False defines the linear shallow water equations</span>
<span class="sd">        :kwarg bool include_grad_div_viscosity_term: If True includes grad(nu div(u))</span>
<span class="sd">            viscosity term</span>
<span class="sd">        :kwarg bool include_grad_depth_viscosity_term: If True includes grad(H) term</span>
<span class="sd">            in viscosity operator</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="nb">super</span><span class="p">(</span><span class="n">ShallowWaterEquations</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="n">__init__</span><span class="p">(</span><span class="n">function_space</span><span class="p">,</span> <span class="n">bathymetry</span><span class="p">,</span> <span class="n">nonlin</span><span class="p">)</span>

        <span class="n">u_test</span><span class="p">,</span> <span class="n">eta_test</span> <span class="o">=</span> <span class="n">TestFunctions</span><span class="p">(</span><span class="n">function_space</span><span class="p">)</span>
        <span class="n">u_space</span><span class="p">,</span> <span class="n">eta_space</span> <span class="o">=</span> <span class="n">function_space</span><span class="o">.</span><span class="n">split</span><span class="p">()</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">add_momentum_terms</span><span class="p">(</span><span class="n">u_test</span><span class="p">,</span> <span class="n">u_space</span><span class="p">,</span> <span class="n">eta_space</span><span class="p">,</span>
                                <span class="n">bathymetry</span><span class="p">,</span>
                                <span class="n">nonlin</span><span class="p">,</span>
                                <span class="n">include_grad_div_viscosity_term</span><span class="p">,</span>
                                <span class="n">include_grad_depth_viscosity_term</span><span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">add_continuity_terms</span><span class="p">(</span><span class="n">eta_test</span><span class="p">,</span> <span class="n">eta_space</span><span class="p">,</span> <span class="n">u_space</span><span class="p">,</span> <span class="n">bathymetry</span><span class="p">,</span> <span class="n">nonlin</span><span class="p">)</span>

<div class="viewcode-block" id="ShallowWaterEquations.residual"><a class="viewcode-back" href="../../thetis.html#thetis.shallowwater_eq.ShallowWaterEquations.residual">[docs]</a>    <span class="k">def</span> <span class="nf">residual</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">label</span><span class="p">,</span> <span class="n">solution</span><span class="p">,</span> <span class="n">solution_old</span><span class="p">,</span> <span class="n">fields</span><span class="p">,</span> <span class="n">fields_old</span><span class="p">,</span> <span class="n">bnd_conditions</span><span class="p">):</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">solution</span><span class="p">,</span> <span class="nb">list</span><span class="p">):</span>
            <span class="n">uv</span><span class="p">,</span> <span class="n">eta</span> <span class="o">=</span> <span class="n">solution</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">uv</span><span class="p">,</span> <span class="n">eta</span> <span class="o">=</span> <span class="n">split</span><span class="p">(</span><span class="n">solution</span><span class="p">)</span>
        <span class="n">uv_old</span><span class="p">,</span> <span class="n">eta_old</span> <span class="o">=</span> <span class="n">split</span><span class="p">(</span><span class="n">solution_old</span><span class="p">)</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">residual_uv_eta</span><span class="p">(</span><span class="n">label</span><span class="p">,</span> <span class="n">uv</span><span class="p">,</span> <span class="n">eta</span><span class="p">,</span> <span class="n">uv_old</span><span class="p">,</span> <span class="n">eta_old</span><span class="p">,</span> <span class="n">fields</span><span class="p">,</span> <span class="n">fields_old</span><span class="p">,</span> <span class="n">bnd_conditions</span><span class="p">)</span></div></div>


<div class="viewcode-block" id="ModeSplit2DEquations"><a class="viewcode-back" href="../../thetis.html#thetis.shallowwater_eq.ModeSplit2DEquations">[docs]</a><span class="k">class</span> <span class="nc">ModeSplit2DEquations</span><span class="p">(</span><span class="n">BaseShallowWaterEquation</span><span class="p">):</span>
    <span class="sd">r&quot;&quot;&quot;</span>
<span class="sd">    2D depth-averaged shallow water equations for mode splitting schemes.</span>

<span class="sd">    Defines the equations :eq:`swe_freesurf_modesplit` -</span>
<span class="sd">    :eq:`swe_momentum_modesplit`.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">function_space</span><span class="p">,</span>
                 <span class="n">bathymetry</span><span class="p">,</span>
                 <span class="n">nonlin</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
                 <span class="n">include_grad_div_viscosity_term</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
                 <span class="n">include_grad_depth_viscosity_term</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        :arg function_space: Mixed function space where the solution belongs</span>
<span class="sd">        :arg bathymetry: bathymetry of the domain</span>
<span class="sd">        :type bathymetry: :class:`Function` or :class:`Constant`</span>
<span class="sd">        :kwarg bool nonlin: If False defines the linear shallow water equations</span>
<span class="sd">        :kwarg bool include_grad_div_viscosity_term: If True includes grad(nu div(u))</span>
<span class="sd">            viscosity term</span>
<span class="sd">        :kwarg bool include_grad_depth_viscosity_term: If True includes grad(H) term</span>
<span class="sd">            in viscosity operator</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># TODO remove include_grad_* options as viscosity operator is omitted</span>
        <span class="nb">super</span><span class="p">(</span><span class="n">ModeSplit2DEquations</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="n">__init__</span><span class="p">(</span><span class="n">function_space</span><span class="p">,</span> <span class="n">bathymetry</span><span class="p">,</span> <span class="n">nonlin</span><span class="p">)</span>

        <span class="n">u_test</span><span class="p">,</span> <span class="n">eta_test</span> <span class="o">=</span> <span class="n">TestFunctions</span><span class="p">(</span><span class="n">function_space</span><span class="p">)</span>
        <span class="n">u_space</span><span class="p">,</span> <span class="n">eta_space</span> <span class="o">=</span> <span class="n">function_space</span><span class="o">.</span><span class="n">split</span><span class="p">()</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">add_momentum_terms</span><span class="p">(</span><span class="n">u_test</span><span class="p">,</span> <span class="n">u_space</span><span class="p">,</span> <span class="n">eta_space</span><span class="p">,</span>
                                <span class="n">bathymetry</span><span class="p">,</span>
                                <span class="n">nonlin</span><span class="p">,</span>
                                <span class="n">include_grad_div_viscosity_term</span><span class="p">,</span>
                                <span class="n">include_grad_depth_viscosity_term</span><span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">add_continuity_terms</span><span class="p">(</span><span class="n">eta_test</span><span class="p">,</span> <span class="n">eta_space</span><span class="p">,</span> <span class="n">u_space</span><span class="p">,</span> <span class="n">bathymetry</span><span class="p">,</span> <span class="n">nonlin</span><span class="p">)</span>

<div class="viewcode-block" id="ModeSplit2DEquations.add_momentum_terms"><a class="viewcode-back" href="../../thetis.html#thetis.shallowwater_eq.ModeSplit2DEquations.add_momentum_terms">[docs]</a>    <span class="k">def</span> <span class="nf">add_momentum_terms</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">add_term</span><span class="p">(</span><span class="n">ExternalPressureGradientTerm</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">),</span> <span class="s1">&#39;implicit&#39;</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">add_term</span><span class="p">(</span><span class="n">CoriolisTerm</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">),</span> <span class="s1">&#39;explicit&#39;</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">add_term</span><span class="p">(</span><span class="n">InternalPressureGradientTerm</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">),</span> <span class="s1">&#39;source&#39;</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">add_term</span><span class="p">(</span><span class="n">MomentumSourceTerm</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">),</span> <span class="s1">&#39;source&#39;</span><span class="p">)</span></div>

<div class="viewcode-block" id="ModeSplit2DEquations.residual"><a class="viewcode-back" href="../../thetis.html#thetis.shallowwater_eq.ModeSplit2DEquations.residual">[docs]</a>    <span class="k">def</span> <span class="nf">residual</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">label</span><span class="p">,</span> <span class="n">solution</span><span class="p">,</span> <span class="n">solution_old</span><span class="p">,</span> <span class="n">fields</span><span class="p">,</span> <span class="n">fields_old</span><span class="p">,</span> <span class="n">bnd_conditions</span><span class="p">):</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">solution</span><span class="p">,</span> <span class="nb">list</span><span class="p">):</span>
            <span class="n">uv</span><span class="p">,</span> <span class="n">eta</span> <span class="o">=</span> <span class="n">solution</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">uv</span><span class="p">,</span> <span class="n">eta</span> <span class="o">=</span> <span class="n">split</span><span class="p">(</span><span class="n">solution</span><span class="p">)</span>
        <span class="n">uv_old</span><span class="p">,</span> <span class="n">eta_old</span> <span class="o">=</span> <span class="n">split</span><span class="p">(</span><span class="n">solution_old</span><span class="p">)</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">residual_uv_eta</span><span class="p">(</span><span class="n">label</span><span class="p">,</span> <span class="n">uv</span><span class="p">,</span> <span class="n">eta</span><span class="p">,</span> <span class="n">uv_old</span><span class="p">,</span> <span class="n">eta_old</span><span class="p">,</span> <span class="n">fields</span><span class="p">,</span> <span class="n">fields_old</span><span class="p">,</span> <span class="n">bnd_conditions</span><span class="p">)</span></div></div>


<div class="viewcode-block" id="FreeSurfaceEquation"><a class="viewcode-back" href="../../thetis.html#thetis.shallowwater_eq.FreeSurfaceEquation">[docs]</a><span class="k">class</span> <span class="nc">FreeSurfaceEquation</span><span class="p">(</span><span class="n">BaseShallowWaterEquation</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    2D free surface equation :eq:`swe_freesurf` in non-conservative form.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">eta_test</span><span class="p">,</span> <span class="n">eta_space</span><span class="p">,</span> <span class="n">u_space</span><span class="p">,</span>
                 <span class="n">bathymetry</span><span class="p">,</span>
                 <span class="n">nonlin</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        :arg eta_test: test function of the elevation function space</span>
<span class="sd">        :arg eta_space: elevation function space</span>
<span class="sd">        :arg u_space: velocity function space</span>
<span class="sd">        :arg function_space: Mixed function space where the solution belongs</span>
<span class="sd">        :arg bathymetry: bathymetry of the domain</span>
<span class="sd">        :type bathymetry: :class:`Function` or :class:`Constant`</span>
<span class="sd">        :kwarg bool nonlin: If False defines the linear shallow water equations</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="nb">super</span><span class="p">(</span><span class="n">FreeSurfaceEquation</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="n">__init__</span><span class="p">(</span><span class="n">eta_space</span><span class="p">,</span> <span class="n">bathymetry</span><span class="p">,</span> <span class="n">nonlin</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">add_continuity_terms</span><span class="p">(</span><span class="n">eta_test</span><span class="p">,</span> <span class="n">eta_space</span><span class="p">,</span> <span class="n">u_space</span><span class="p">,</span> <span class="n">bathymetry</span><span class="p">,</span> <span class="n">nonlin</span><span class="p">)</span>

<div class="viewcode-block" id="FreeSurfaceEquation.residual"><a class="viewcode-back" href="../../thetis.html#thetis.shallowwater_eq.FreeSurfaceEquation.residual">[docs]</a>    <span class="k">def</span> <span class="nf">residual</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">label</span><span class="p">,</span> <span class="n">solution</span><span class="p">,</span> <span class="n">solution_old</span><span class="p">,</span> <span class="n">fields</span><span class="p">,</span> <span class="n">fields_old</span><span class="p">,</span> <span class="n">bnd_conditions</span><span class="p">):</span>
        <span class="n">uv</span> <span class="o">=</span> <span class="n">fields</span><span class="p">[</span><span class="s1">&#39;uv&#39;</span><span class="p">]</span>
        <span class="n">uv_old</span> <span class="o">=</span> <span class="n">fields_old</span><span class="p">[</span><span class="s1">&#39;uv&#39;</span><span class="p">]</span>
        <span class="n">eta</span> <span class="o">=</span> <span class="n">solution</span>
        <span class="n">eta_old</span> <span class="o">=</span> <span class="n">solution_old</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">residual_uv_eta</span><span class="p">(</span><span class="n">label</span><span class="p">,</span> <span class="n">uv</span><span class="p">,</span> <span class="n">eta</span><span class="p">,</span> <span class="n">uv_old</span><span class="p">,</span> <span class="n">eta_old</span><span class="p">,</span> <span class="n">fields</span><span class="p">,</span> <span class="n">fields_old</span><span class="p">,</span> <span class="n">bnd_conditions</span><span class="p">)</span></div></div>


<div class="viewcode-block" id="ShallowWaterMomentumEquation"><a class="viewcode-back" href="../../thetis.html#thetis.shallowwater_eq.ShallowWaterMomentumEquation">[docs]</a><span class="k">class</span> <span class="nc">ShallowWaterMomentumEquation</span><span class="p">(</span><span class="n">BaseShallowWaterEquation</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    2D depth averaged momentum equation :eq:`swe_momentum` in non-conservative</span>
<span class="sd">    form.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">eta_test</span><span class="p">,</span> <span class="n">eta_space</span><span class="p">,</span> <span class="n">u_space</span><span class="p">,</span>
                 <span class="n">bathymetry</span><span class="p">,</span>
                 <span class="n">nonlin</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
                 <span class="n">include_grad_div_viscosity_term</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
                 <span class="n">include_grad_depth_viscosity_term</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        :arg eta_test: test function of the elevation function space</span>
<span class="sd">        :arg eta_space: elevation function space</span>
<span class="sd">        :arg u_space: velocity function space</span>
<span class="sd">        :arg function_space: Mixed function space where the solution belongs</span>
<span class="sd">        :arg bathymetry: bathymetry of the domain</span>
<span class="sd">        :type bathymetry: :class:`Function` or :class:`Constant`</span>
<span class="sd">        :kwarg bool nonlin: If False defines the linear shallow water equations</span>
<span class="sd">        :kwarg bool include_grad_div_viscosity_term: If True includes grad(nu div(u))</span>
<span class="sd">            viscosity term</span>
<span class="sd">        :kwarg bool include_grad_depth_viscosity_term: If True includes grad(H) term</span>
<span class="sd">            in viscosity operator</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="nb">super</span><span class="p">(</span><span class="n">ShallowWaterMomentumEquation</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="n">__init__</span><span class="p">(</span><span class="n">u_space</span><span class="p">,</span> <span class="n">bathymetry</span><span class="p">,</span> <span class="n">nonlin</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">add_momentum_terms</span><span class="p">(</span><span class="n">eta_test</span><span class="p">,</span> <span class="n">u_space</span><span class="p">,</span> <span class="n">eta_space</span><span class="p">,</span>
                                <span class="n">bathymetry</span><span class="p">,</span>
                                <span class="n">nonlin</span><span class="p">,</span>
                                <span class="n">include_grad_div_viscosity_term</span><span class="p">,</span>
                                <span class="n">include_grad_depth_viscosity_term</span><span class="p">)</span>

<div class="viewcode-block" id="ShallowWaterMomentumEquation.residual"><a class="viewcode-back" href="../../thetis.html#thetis.shallowwater_eq.ShallowWaterMomentumEquation.residual">[docs]</a>    <span class="k">def</span> <span class="nf">residual</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">label</span><span class="p">,</span> <span class="n">solution</span><span class="p">,</span> <span class="n">solution_old</span><span class="p">,</span> <span class="n">fields</span><span class="p">,</span> <span class="n">fields_old</span><span class="p">,</span> <span class="n">bnd_conditions</span><span class="p">):</span>
        <span class="n">uv</span> <span class="o">=</span> <span class="n">solution</span>
        <span class="n">uv_old</span> <span class="o">=</span> <span class="n">solution_old</span>
        <span class="n">eta</span> <span class="o">=</span> <span class="n">fields</span><span class="p">[</span><span class="s1">&#39;eta&#39;</span><span class="p">]</span>
        <span class="n">eta_old</span> <span class="o">=</span> <span class="n">fields_old</span><span class="p">[</span><span class="s1">&#39;eta&#39;</span><span class="p">]</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">residual_uv_eta</span><span class="p">(</span><span class="n">label</span><span class="p">,</span> <span class="n">uv</span><span class="p">,</span> <span class="n">eta</span><span class="p">,</span> <span class="n">uv_old</span><span class="p">,</span> <span class="n">eta_old</span><span class="p">,</span> <span class="n">fields</span><span class="p">,</span> <span class="n">fields_old</span><span class="p">,</span> <span class="n">bnd_conditions</span><span class="p">)</span></div></div>
</pre></div>

          </div>
        </div>
      </div>
    </div>
      <div class="clearer"></div>
    </div>
    <div class="footer" role="contentinfo">
        &#169; Copyright 2016, Tuomas Karna et al..
      Created using <a href="http://sphinx-doc.org/">Sphinx</a> 1.5.
    </div>
  </body>
</html>