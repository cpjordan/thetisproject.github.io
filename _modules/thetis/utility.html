
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">

<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta http-equiv="X-UA-Compatible" content="IE=Edge" />
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    <title>thetis.utility &#8212; Thetis 0+untagged.1213.g0b06141 documentation</title>
    <link rel="stylesheet" href="../../_static/thetis.css" type="text/css" />
    <link rel="stylesheet" href="../../_static/pygments.css" type="text/css" />
    <script type="text/javascript" src="../../_static/documentation_options.js"></script>
    <script type="text/javascript" src="../../_static/jquery.js"></script>
    <script type="text/javascript" src="../../_static/underscore.js"></script>
    <script type="text/javascript" src="../../_static/doctools.js"></script>
    <script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
    <link rel="index" title="Index" href="../../genindex.html" />
    <link rel="search" title="Search" href="../../search.html" />
<!--[if lte IE 6]>
<link rel="stylesheet" href="../../_static/ie6.css" type="text/css" media="screen" charset="utf-8" />
<![endif]-->

<!-- <link rel="stylesheet" href="../../_static/featured.css"> -->


<link rel="shortcut icon" href="../../_static/icon_thetis.ico" />


  </head><body>
<div class="wrapper">
  <a href="../../index.html"><img src="../../_static/banner.jpg" height="180px" alt="Thetis Project Banner" /></a>
  <div id="access">
    <div class="menu">
      <ul>
        <li class="page_item"><a href="../../documentation.html" title="Thetis documentation">Documentation</a></li>
        <li class="page_item"><a href="../../download.html" title="Install Thetis">Download</a></li>
        <li class="page_item"><a href="../../team.html" title="Development team">Team</a></li>
        <li class="page_item"><a href="../../publications.html" title="Publications">Publications</a></li>
        <li class="page_item"><a href="../../funding.html" title="Our financial supporters">Funding</a></li>
        <li class="page_item"><a href="../../contact.html" title="Getting in touch">Contact</a></li>
        <li class="page_item"><a href="https://github.com/thetisproject/thetis" title="Thetis source on GitHub">GitHub</a></li>
        <li class="page_item"><a href="https://jenkins.ese.ic.ac.uk:1080/blue/organizations/jenkins/thetisproject%2Fthetis/activity" title="Thetis build status">Jenkins</a></li>
      </ul>
    </div><!-- .menu -->
  </div><!-- #access -->
</div><!-- #wrapper -->


    <div class="document">
    <div class="_modules/thetis/utility">
      
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body" role="main">
            
  <h1>Source code for thetis.utility</h1><div class="highlight"><pre>
<span></span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">Utility functions and classes for 3D hydrostatic ocean model</span>
<span class="sd">&quot;&quot;&quot;</span>
<span class="kn">from</span> <span class="nn">__future__</span> <span class="k">import</span> <span class="n">absolute_import</span>
<span class="kn">from</span> <span class="nn">.firedrake</span> <span class="k">import</span> <span class="o">*</span>
<span class="kn">import</span> <span class="nn">os</span>
<span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>
<span class="kn">import</span> <span class="nn">sys</span>
<span class="kn">from</span> <span class="nn">.physical_constants</span> <span class="k">import</span> <span class="n">physical_constants</span>
<span class="kn">from</span> <span class="nn">pyop2.profiling</span> <span class="k">import</span> <span class="n">timed_region</span><span class="p">,</span> <span class="n">timed_function</span><span class="p">,</span> <span class="n">timed_stage</span>  <span class="c1"># NOQA</span>
<span class="kn">from</span> <span class="nn">mpi4py</span> <span class="k">import</span> <span class="n">MPI</span>  <span class="c1"># NOQA</span>
<span class="kn">import</span> <span class="nn">ufl</span>  <span class="c1"># NOQA</span>
<span class="kn">import</span> <span class="nn">coffee.base</span> <span class="k">as</span> <span class="nn">ast</span>  <span class="c1"># NOQA</span>
<span class="kn">from</span> <span class="nn">collections</span> <span class="k">import</span> <span class="n">OrderedDict</span><span class="p">,</span> <span class="n">namedtuple</span>  <span class="c1"># NOQA</span>
<span class="kn">from</span> <span class="nn">.field_defs</span> <span class="k">import</span> <span class="n">field_metadata</span>
<span class="kn">from</span> <span class="nn">.log</span> <span class="k">import</span> <span class="o">*</span>
<span class="kn">from</span> <span class="nn">firedrake</span> <span class="k">import</span> <span class="n">Function</span> <span class="k">as</span> <span class="n">FiredrakeFunction</span>
<span class="kn">from</span> <span class="nn">firedrake</span> <span class="k">import</span> <span class="n">Constant</span> <span class="k">as</span> <span class="n">FiredrakeConstant</span>
<span class="kn">from</span> <span class="nn">abc</span> <span class="k">import</span> <span class="n">ABCMeta</span><span class="p">,</span> <span class="n">abstractmethod</span>

<span class="n">ds_surf</span> <span class="o">=</span> <span class="n">ds_t</span>
<span class="n">ds_bottom</span> <span class="o">=</span> <span class="n">ds_b</span>

<span class="c1"># TODO move 3d model classes to separate module</span>


<div class="viewcode-block" id="FrozenClass"><a class="viewcode-back" href="../../thetis.html#thetis.utility.FrozenClass">[docs]</a><span class="k">class</span> <span class="nc">FrozenClass</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;A class where creating a new attribute will raise an exception if _isfrozen == True&quot;&quot;&quot;</span>
    <span class="n">_isfrozen</span> <span class="o">=</span> <span class="kc">False</span>

    <span class="k">def</span> <span class="nf">__setattr__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">key</span><span class="p">,</span> <span class="n">value</span><span class="p">):</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_isfrozen</span> <span class="ow">and</span> <span class="ow">not</span> <span class="nb">hasattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">key</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s1">&#39;Adding new attribute &quot;</span><span class="si">{:}</span><span class="s1">&quot; to </span><span class="si">{:}</span><span class="s1"> class is forbidden&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">key</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="o">.</span><span class="vm">__name__</span><span class="p">))</span>
        <span class="nb">super</span><span class="p">(</span><span class="n">FrozenClass</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="fm">__setattr__</span><span class="p">(</span><span class="n">key</span><span class="p">,</span> <span class="n">value</span><span class="p">)</span></div>


<div class="viewcode-block" id="SumFunction"><a class="viewcode-back" href="../../thetis.html#thetis.utility.SumFunction">[docs]</a><span class="k">class</span> <span class="nc">SumFunction</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Helper class to keep track of sum of Coefficients.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Initialize empty sum.</span>

<span class="sd">        get operation returns Constant(0)</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">coeff_list</span> <span class="o">=</span> <span class="p">[]</span>

<div class="viewcode-block" id="SumFunction.add"><a class="viewcode-back" href="../../thetis.html#thetis.utility.SumFunction.add">[docs]</a>    <span class="k">def</span> <span class="nf">add</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">coeff</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Adds a coefficient to self</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">coeff</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">return</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">coeff_list</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">coeff</span><span class="p">)</span></div>

<div class="viewcode-block" id="SumFunction.get_sum"><a class="viewcode-back" href="../../thetis.html#thetis.utility.SumFunction.get_sum">[docs]</a>    <span class="k">def</span> <span class="nf">get_sum</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns a sum of all added Coefficients</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">coeff_list</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">return</span> <span class="kc">None</span>
        <span class="k">return</span> <span class="nb">sum</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">coeff_list</span><span class="p">)</span></div></div>


<div class="viewcode-block" id="AttrDict"><a class="viewcode-back" href="../../thetis.html#thetis.utility.AttrDict">[docs]</a><span class="k">class</span> <span class="nc">AttrDict</span><span class="p">(</span><span class="nb">dict</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Dictionary that provides both self[&#39;key&#39;] and self.key access to members.</span>

<span class="sd">    http://stackoverflow.com/questions/4984647/accessing-dict-keys-like-an-attribute-in-python</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">sys</span><span class="o">.</span><span class="n">version_info</span> <span class="o">&lt;</span> <span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="mi">7</span><span class="p">,</span> <span class="mi">4</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="s1">&#39;AttrDict requires python &gt;= 2.7.4 to avoid memory leaks&#39;</span><span class="p">)</span>
        <span class="nb">super</span><span class="p">(</span><span class="n">AttrDict</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="vm">__dict__</span> <span class="o">=</span> <span class="bp">self</span></div>


<div class="viewcode-block" id="FieldDict"><a class="viewcode-back" href="../../thetis.html#thetis.utility.FieldDict">[docs]</a><span class="k">class</span> <span class="nc">FieldDict</span><span class="p">(</span><span class="n">AttrDict</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    AttrDict that checks that all added fields have proper meta data.</span>

<span class="sd">    Values can be either Function or Constant objects.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">def</span> <span class="nf">_check_inputs</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">key</span><span class="p">,</span> <span class="n">value</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">key</span> <span class="o">!=</span> <span class="s1">&#39;__dict__&#39;</span><span class="p">:</span>
            <span class="kn">from</span> <span class="nn">firedrake.functionspaceimpl</span> <span class="k">import</span> <span class="n">MixedFunctionSpace</span><span class="p">,</span> <span class="n">WithGeometry</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">value</span><span class="p">,</span> <span class="p">(</span><span class="n">FiredrakeFunction</span><span class="p">,</span> <span class="n">FiredrakeConstant</span><span class="p">)):</span>
                <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s1">&#39;Value must be a Function or Constant object&#39;</span><span class="p">)</span>
            <span class="n">fs</span> <span class="o">=</span> <span class="n">value</span><span class="o">.</span><span class="n">function_space</span><span class="p">()</span>
            <span class="n">is_mixed</span> <span class="o">=</span> <span class="p">(</span><span class="nb">isinstance</span><span class="p">(</span><span class="n">fs</span><span class="p">,</span> <span class="n">MixedFunctionSpace</span><span class="p">)</span> <span class="ow">or</span>
                        <span class="p">(</span><span class="nb">isinstance</span><span class="p">(</span><span class="n">fs</span><span class="p">,</span> <span class="n">WithGeometry</span><span class="p">)</span> <span class="ow">and</span>
                         <span class="nb">isinstance</span><span class="p">(</span><span class="n">fs</span><span class="o">.</span><span class="n">topological</span><span class="p">,</span> <span class="n">MixedFunctionSpace</span><span class="p">)))</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">is_mixed</span> <span class="ow">and</span> <span class="n">key</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">field_metadata</span><span class="p">:</span>
                <span class="n">msg</span> <span class="o">=</span> <span class="s1">&#39;Trying to add a field &quot;</span><span class="si">{:}</span><span class="s1">&quot; that has no metadata. &#39;</span> \
                      <span class="s1">&#39;Add field_metadata entry to field_defs.py&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">key</span><span class="p">)</span>
                <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="n">msg</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">_set_functionname</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">key</span><span class="p">,</span> <span class="n">value</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Set function.name to key to ensure consistent naming&quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">value</span><span class="p">,</span> <span class="n">FiredrakeFunction</span><span class="p">):</span>
            <span class="n">value</span><span class="o">.</span><span class="n">rename</span><span class="p">(</span><span class="n">name</span><span class="o">=</span><span class="n">key</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">__setitem__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">key</span><span class="p">,</span> <span class="n">value</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_check_inputs</span><span class="p">(</span><span class="n">key</span><span class="p">,</span> <span class="n">value</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_set_functionname</span><span class="p">(</span><span class="n">key</span><span class="p">,</span> <span class="n">value</span><span class="p">)</span>
        <span class="nb">super</span><span class="p">(</span><span class="n">FieldDict</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="fm">__setitem__</span><span class="p">(</span><span class="n">key</span><span class="p">,</span> <span class="n">value</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">__setattr__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">key</span><span class="p">,</span> <span class="n">value</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_check_inputs</span><span class="p">(</span><span class="n">key</span><span class="p">,</span> <span class="n">value</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_set_functionname</span><span class="p">(</span><span class="n">key</span><span class="p">,</span> <span class="n">value</span><span class="p">)</span>
        <span class="nb">super</span><span class="p">(</span><span class="n">FieldDict</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="fm">__setattr__</span><span class="p">(</span><span class="n">key</span><span class="p">,</span> <span class="n">value</span><span class="p">)</span></div>


<span class="n">ElementContinuity</span> <span class="o">=</span> <span class="n">namedtuple</span><span class="p">(</span><span class="s2">&quot;ElementContinuity&quot;</span><span class="p">,</span> <span class="p">[</span><span class="s2">&quot;horizontal&quot;</span><span class="p">,</span> <span class="s2">&quot;vertical&quot;</span><span class="p">])</span>
<span class="sd">&quot;&quot;&quot;</span>
<span class="sd">A named tuple describing the continuity of an element in the horizontal/vertical direction.</span>

<span class="sd">The field value is one of &quot;cg&quot;, &quot;hdiv&quot;, or &quot;dg&quot;.</span>
<span class="sd">&quot;&quot;&quot;</span>


<div class="viewcode-block" id="element_continuity"><a class="viewcode-back" href="../../thetis.html#thetis.utility.element_continuity">[docs]</a><span class="k">def</span> <span class="nf">element_continuity</span><span class="p">(</span><span class="n">ufl_element</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Return an :class:`ElementContinuity` instance with the</span>
<span class="sd">    continuity of a given element.</span>

<span class="sd">    :arg ufl_element: The UFL element to determine the continuity</span>
<span class="sd">        of.</span>
<span class="sd">    :returns: A new :class:`ElementContinuity` instance.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">elem</span> <span class="o">=</span> <span class="n">ufl_element</span>
    <span class="n">elem_types</span> <span class="o">=</span> <span class="p">{</span>
        <span class="s1">&#39;Discontinuous Lagrange&#39;</span><span class="p">:</span> <span class="s1">&#39;dg&#39;</span><span class="p">,</span>
        <span class="s1">&#39;Lagrange&#39;</span><span class="p">:</span> <span class="s1">&#39;cg&#39;</span><span class="p">,</span>
        <span class="s1">&#39;Raviart-Thomas&#39;</span><span class="p">:</span> <span class="s1">&#39;hdiv&#39;</span><span class="p">,</span>
    <span class="p">}</span>

    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">elem</span><span class="p">,</span> <span class="n">ufl</span><span class="o">.</span><span class="n">finiteelement</span><span class="o">.</span><span class="n">mixedelement</span><span class="o">.</span><span class="n">MixedElement</span><span class="p">):</span>
        <span class="n">elem</span> <span class="o">=</span> <span class="n">elem</span><span class="o">.</span><span class="n">sub_elements</span><span class="p">()[</span><span class="mi">0</span><span class="p">]</span>
    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">elem</span><span class="p">,</span> <span class="n">ufl</span><span class="o">.</span><span class="n">finiteelement</span><span class="o">.</span><span class="n">mixedelement</span><span class="o">.</span><span class="n">VectorElement</span><span class="p">):</span>
        <span class="n">elem</span> <span class="o">=</span> <span class="n">elem</span><span class="o">.</span><span class="n">sub_elements</span><span class="p">()[</span><span class="mi">0</span><span class="p">]</span>  <span class="c1"># take the elem of first component</span>
    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">elem</span><span class="p">,</span> <span class="n">ufl</span><span class="o">.</span><span class="n">finiteelement</span><span class="o">.</span><span class="n">tensorproductelement</span><span class="o">.</span><span class="n">TensorProductElement</span><span class="p">):</span>
        <span class="n">a</span><span class="p">,</span> <span class="n">b</span> <span class="o">=</span> <span class="n">elem</span><span class="o">.</span><span class="n">sub_elements</span><span class="p">()</span>
        <span class="n">horiz_type</span> <span class="o">=</span> <span class="n">elem_types</span><span class="p">[</span><span class="n">a</span><span class="o">.</span><span class="n">family</span><span class="p">()]</span>
        <span class="n">vert_type</span> <span class="o">=</span> <span class="n">elem_types</span><span class="p">[</span><span class="n">b</span><span class="o">.</span><span class="n">family</span><span class="p">()]</span>
    <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">elem</span><span class="p">,</span> <span class="n">ufl</span><span class="o">.</span><span class="n">finiteelement</span><span class="o">.</span><span class="n">hdivcurl</span><span class="o">.</span><span class="n">HDivElement</span><span class="p">):</span>
        <span class="n">horiz_type</span> <span class="o">=</span> <span class="s1">&#39;hdiv&#39;</span>
        <span class="n">vert_type</span> <span class="o">=</span> <span class="s1">&#39;hdiv&#39;</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">horiz_type</span> <span class="o">=</span> <span class="n">elem_types</span><span class="p">[</span><span class="n">elem</span><span class="o">.</span><span class="n">family</span><span class="p">()]</span>
        <span class="n">vert_type</span> <span class="o">=</span> <span class="n">horiz_type</span>
    <span class="k">return</span> <span class="n">ElementContinuity</span><span class="p">(</span><span class="n">horiz_type</span><span class="p">,</span> <span class="n">vert_type</span><span class="p">)</span></div>


<div class="viewcode-block" id="create_directory"><a class="viewcode-back" href="../../thetis.html#thetis.utility.create_directory">[docs]</a><span class="k">def</span> <span class="nf">create_directory</span><span class="p">(</span><span class="n">path</span><span class="p">,</span> <span class="n">comm</span><span class="o">=</span><span class="n">COMM_WORLD</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Create a directory on disk</span>

<span class="sd">    Raises IOError if a file with the same name already exists.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="n">comm</span><span class="o">.</span><span class="n">rank</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">exists</span><span class="p">(</span><span class="n">path</span><span class="p">):</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">isdir</span><span class="p">(</span><span class="n">path</span><span class="p">):</span>
                <span class="k">raise</span> <span class="ne">IOError</span><span class="p">(</span><span class="s1">&#39;file with same name exists&#39;</span><span class="p">,</span> <span class="n">path</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">os</span><span class="o">.</span><span class="n">makedirs</span><span class="p">(</span><span class="n">path</span><span class="p">)</span>
    <span class="n">comm</span><span class="o">.</span><span class="n">barrier</span><span class="p">()</span>
    <span class="k">return</span> <span class="n">path</span></div>


<div class="viewcode-block" id="get_facet_mask"><a class="viewcode-back" href="../../thetis.html#thetis.utility.get_facet_mask">[docs]</a><span class="k">def</span> <span class="nf">get_facet_mask</span><span class="p">(</span><span class="n">function_space</span><span class="p">,</span> <span class="n">mode</span><span class="o">=</span><span class="s1">&#39;geometric&#39;</span><span class="p">,</span> <span class="n">facet</span><span class="o">=</span><span class="s1">&#39;bottom&#39;</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Returns the top/bottom nodes of extruded 3D elements.</span>

<span class="sd">    :arg function_space: Firedrake :class:`FunctionSpace` object</span>
<span class="sd">    :kwarg str mode: &#39;topological&#39;, to retrieve nodes that lie on the facet, or</span>
<span class="sd">        &#39;geometric&#39; for nodes whose basis functions do not vanish on the facet.</span>
<span class="sd">    :kwarg str facet: &#39;top&#39; or &#39;bottom&#39;</span>

<span class="sd">    .. note::</span>
<span class="sd">        The definition of top/bottom depends on the direction of the extrusion.</span>
<span class="sd">        Here we assume that the mesh has been extruded upwards (along positive</span>
<span class="sd">        z axis).</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">section</span><span class="p">,</span> <span class="n">iset</span><span class="p">,</span> <span class="n">facets</span> <span class="o">=</span> <span class="n">function_space</span><span class="o">.</span><span class="n">cell_boundary_masks</span><span class="p">[</span><span class="n">mode</span><span class="p">]</span>
    <span class="n">ifacet</span> <span class="o">=</span> <span class="o">-</span><span class="mi">2</span> <span class="k">if</span> <span class="n">facet</span> <span class="o">==</span> <span class="s1">&#39;bottom&#39;</span> <span class="k">else</span> <span class="o">-</span><span class="mi">1</span>
    <span class="n">off</span> <span class="o">=</span> <span class="n">section</span><span class="o">.</span><span class="n">getOffset</span><span class="p">(</span><span class="n">facets</span><span class="p">[</span><span class="n">ifacet</span><span class="p">])</span>
    <span class="n">dof</span> <span class="o">=</span> <span class="n">section</span><span class="o">.</span><span class="n">getDof</span><span class="p">(</span><span class="n">facets</span><span class="p">[</span><span class="n">ifacet</span><span class="p">])</span>
    <span class="n">indices</span> <span class="o">=</span> <span class="n">iset</span><span class="p">[</span><span class="n">off</span><span class="p">:</span><span class="n">off</span><span class="o">+</span><span class="n">dof</span><span class="p">]</span>
    <span class="k">return</span> <span class="n">indices</span></div>


<div class="viewcode-block" id="extrude_mesh_sigma"><a class="viewcode-back" href="../../thetis.html#thetis.utility.extrude_mesh_sigma">[docs]</a><span class="k">def</span> <span class="nf">extrude_mesh_sigma</span><span class="p">(</span><span class="n">mesh2d</span><span class="p">,</span> <span class="n">n_layers</span><span class="p">,</span> <span class="n">bathymetry_2d</span><span class="p">,</span> <span class="n">z_stretch_fact</span><span class="o">=</span><span class="mf">1.0</span><span class="p">,</span>
                       <span class="n">min_depth</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Extrudes a 2d surface mesh with bathymetry data defined in a 2d field.</span>

<span class="sd">    Generates a uniform terrain following mesh.</span>

<span class="sd">    :arg mesh2d: 2D mesh</span>
<span class="sd">    :arg n_layers: number of vertical layers</span>
<span class="sd">    :arg bathymetry: 2D :class:`Function` of the bathymetry</span>
<span class="sd">        (the depth of the domain; positive downwards)</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">mesh</span> <span class="o">=</span> <span class="n">ExtrudedMesh</span><span class="p">(</span><span class="n">mesh2d</span><span class="p">,</span> <span class="n">layers</span><span class="o">=</span><span class="n">n_layers</span><span class="p">,</span> <span class="n">layer_height</span><span class="o">=</span><span class="mf">1.0</span><span class="o">/</span><span class="n">n_layers</span><span class="p">)</span>

    <span class="n">coordinates</span> <span class="o">=</span> <span class="n">mesh</span><span class="o">.</span><span class="n">coordinates</span>
    <span class="n">fs_3d</span> <span class="o">=</span> <span class="n">coordinates</span><span class="o">.</span><span class="n">function_space</span><span class="p">()</span>
    <span class="n">fs_2d</span> <span class="o">=</span> <span class="n">bathymetry_2d</span><span class="o">.</span><span class="n">function_space</span><span class="p">()</span>
    <span class="n">new_coordinates</span> <span class="o">=</span> <span class="n">Function</span><span class="p">(</span><span class="n">fs_3d</span><span class="p">)</span>

    <span class="n">z_stretch_func</span> <span class="o">=</span> <span class="n">Function</span><span class="p">(</span><span class="n">fs_2d</span><span class="p">)</span>
    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">z_stretch_fact</span><span class="p">,</span> <span class="n">FiredrakeFunction</span><span class="p">):</span>
        <span class="k">assert</span> <span class="n">z_stretch_fact</span><span class="o">.</span><span class="n">function_space</span><span class="p">()</span> <span class="o">==</span> <span class="n">fs_2d</span>
        <span class="n">z_stretch_func</span> <span class="o">=</span> <span class="n">z_stretch_fact</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">z_stretch_func</span><span class="o">.</span><span class="n">assign</span><span class="p">(</span><span class="n">z_stretch_fact</span><span class="p">)</span>

    <span class="c1"># number of nodes in vertical direction</span>
    <span class="n">n_vert_nodes</span> <span class="o">=</span> <span class="n">fs_3d</span><span class="o">.</span><span class="n">finat_element</span><span class="o">.</span><span class="n">space_dimension</span><span class="p">()</span> <span class="o">/</span> <span class="n">fs_2d</span><span class="o">.</span><span class="n">finat_element</span><span class="o">.</span><span class="n">space_dimension</span><span class="p">()</span>

    <span class="n">min_depth_arr</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">((</span><span class="n">n_layers</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span> <span class="p">))</span><span class="o">*</span><span class="mf">1e22</span>
    <span class="k">if</span> <span class="n">min_depth</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
        <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">v</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">min_depth</span><span class="p">):</span>
            <span class="n">min_depth_arr</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">v</span>

    <span class="n">nodes</span> <span class="o">=</span> <span class="n">get_facet_mask</span><span class="p">(</span><span class="n">fs_3d</span><span class="p">,</span> <span class="s1">&#39;geometric&#39;</span><span class="p">,</span> <span class="s1">&#39;bottom&#39;</span><span class="p">)</span>
    <span class="n">idx</span> <span class="o">=</span> <span class="n">op2</span><span class="o">.</span><span class="n">Global</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">nodes</span><span class="p">),</span> <span class="n">nodes</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">int32</span><span class="p">,</span> <span class="n">name</span><span class="o">=</span><span class="s1">&#39;node_idx&#39;</span><span class="p">)</span>
    <span class="n">min_depth_op2</span> <span class="o">=</span> <span class="n">op2</span><span class="o">.</span><span class="n">Global</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">min_depth_arr</span><span class="p">),</span> <span class="n">min_depth_arr</span><span class="p">,</span> <span class="n">name</span><span class="o">=</span><span class="s1">&#39;min_depth&#39;</span><span class="p">)</span>
    <span class="n">kernel</span> <span class="o">=</span> <span class="n">op2</span><span class="o">.</span><span class="n">Kernel</span><span class="p">(</span><span class="s2">&quot;&quot;&quot;</span>
<span class="s2">        void my_kernel(double **new_coords, double **old_coords, double **bath2d, double **z_stretch, int *idx, double *min_depth) {</span>
<span class="s2">            for ( int d = 0; d &lt; </span><span class="si">%(nodes)d</span><span class="s2">; d++ ) {</span>
<span class="s2">                double s_fact = z_stretch[d][0];</span>
<span class="s2">                for ( int e = 0; e &lt; </span><span class="si">%(v_nodes)d</span><span class="s2">; e++ ) {</span>
<span class="s2">                    new_coords[idx[d]+e][0] = old_coords[idx[d]+e][0];</span>
<span class="s2">                    new_coords[idx[d]+e][1] = old_coords[idx[d]+e][1];</span>
<span class="s2">                    double sigma = 1.0 - old_coords[idx[d]+e][2]; // top 0, bot 1</span>
<span class="s2">                    double new_z = -bath2d[d][0] * pow(sigma, s_fact) ;</span>
<span class="s2">                    int layer = fmin(fmax(round(sigma*(</span><span class="si">%(n_layers)d</span><span class="s2"> + 1) - 1.0), 0.0), </span><span class="si">%(n_layers)d</span><span class="s2">);</span>
<span class="s2">                    double max_z = -min_depth[layer];</span>
<span class="s2">                    new_z = fmax(new_z, max_z);</span>
<span class="s2">                    new_coords[idx[d]+e][2] = new_z;</span>
<span class="s2">                }</span>
<span class="s2">            }</span>
<span class="s2">        }&quot;&quot;&quot;</span> <span class="o">%</span> <span class="p">{</span><span class="s1">&#39;nodes&#39;</span><span class="p">:</span> <span class="n">fs_2d</span><span class="o">.</span><span class="n">finat_element</span><span class="o">.</span><span class="n">space_dimension</span><span class="p">(),</span>
                <span class="s1">&#39;v_nodes&#39;</span><span class="p">:</span> <span class="n">n_vert_nodes</span><span class="p">,</span>
                <span class="s1">&#39;n_layers&#39;</span><span class="p">:</span> <span class="n">n_layers</span><span class="p">},</span>
        <span class="s1">&#39;my_kernel&#39;</span><span class="p">)</span>

    <span class="n">op2</span><span class="o">.</span><span class="n">par_loop</span><span class="p">(</span><span class="n">kernel</span><span class="p">,</span> <span class="n">mesh</span><span class="o">.</span><span class="n">cell_set</span><span class="p">,</span>
                 <span class="n">new_coordinates</span><span class="o">.</span><span class="n">dat</span><span class="p">(</span><span class="n">op2</span><span class="o">.</span><span class="n">WRITE</span><span class="p">,</span> <span class="n">fs_3d</span><span class="o">.</span><span class="n">cell_node_map</span><span class="p">()),</span>
                 <span class="n">coordinates</span><span class="o">.</span><span class="n">dat</span><span class="p">(</span><span class="n">op2</span><span class="o">.</span><span class="n">READ</span><span class="p">,</span> <span class="n">fs_3d</span><span class="o">.</span><span class="n">cell_node_map</span><span class="p">()),</span>
                 <span class="n">bathymetry_2d</span><span class="o">.</span><span class="n">dat</span><span class="p">(</span><span class="n">op2</span><span class="o">.</span><span class="n">READ</span><span class="p">,</span> <span class="n">fs_2d</span><span class="o">.</span><span class="n">cell_node_map</span><span class="p">()),</span>
                 <span class="n">z_stretch_func</span><span class="o">.</span><span class="n">dat</span><span class="p">(</span><span class="n">op2</span><span class="o">.</span><span class="n">READ</span><span class="p">,</span> <span class="n">fs_2d</span><span class="o">.</span><span class="n">cell_node_map</span><span class="p">()),</span>
                 <span class="n">idx</span><span class="p">(</span><span class="n">op2</span><span class="o">.</span><span class="n">READ</span><span class="p">),</span>
                 <span class="n">min_depth_op2</span><span class="p">(</span><span class="n">op2</span><span class="o">.</span><span class="n">READ</span><span class="p">),</span>
                 <span class="n">iterate</span><span class="o">=</span><span class="n">op2</span><span class="o">.</span><span class="n">ALL</span><span class="p">)</span>

    <span class="n">mesh</span><span class="o">.</span><span class="n">coordinates</span><span class="o">.</span><span class="n">assign</span><span class="p">(</span><span class="n">new_coordinates</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">mesh</span></div>


<div class="viewcode-block" id="comp_volume_2d"><a class="viewcode-back" href="../../thetis.html#thetis.utility.comp_volume_2d">[docs]</a><span class="k">def</span> <span class="nf">comp_volume_2d</span><span class="p">(</span><span class="n">eta</span><span class="p">,</span> <span class="n">bath</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Computes volume of the 2D domain as an integral of the elevation field&quot;&quot;&quot;</span>
    <span class="n">val</span> <span class="o">=</span> <span class="n">assemble</span><span class="p">((</span><span class="n">eta</span><span class="o">+</span><span class="n">bath</span><span class="p">)</span><span class="o">*</span><span class="n">dx</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">val</span></div>


<div class="viewcode-block" id="comp_volume_3d"><a class="viewcode-back" href="../../thetis.html#thetis.utility.comp_volume_3d">[docs]</a><span class="k">def</span> <span class="nf">comp_volume_3d</span><span class="p">(</span><span class="n">mesh</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Computes volume of the 3D domain as an integral&quot;&quot;&quot;</span>
    <span class="n">one</span> <span class="o">=</span> <span class="n">Constant</span><span class="p">(</span><span class="mf">1.0</span><span class="p">,</span> <span class="n">domain</span><span class="o">=</span><span class="n">mesh</span><span class="o">.</span><span class="n">coordinates</span><span class="o">.</span><span class="n">ufl_domain</span><span class="p">())</span>
    <span class="n">val</span> <span class="o">=</span> <span class="n">assemble</span><span class="p">(</span><span class="n">one</span><span class="o">*</span><span class="n">dx</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">val</span></div>


<div class="viewcode-block" id="comp_tracer_mass_2d"><a class="viewcode-back" href="../../thetis.html#thetis.utility.comp_tracer_mass_2d">[docs]</a><span class="k">def</span> <span class="nf">comp_tracer_mass_2d</span><span class="p">(</span><span class="n">eta</span><span class="p">,</span> <span class="n">bath</span><span class="p">,</span> <span class="n">scalar_func</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Computes total tracer mass in the 2D domain</span>
<span class="sd">    :arg eta: elevation :class: &#39;Function&#39;</span>
<span class="sd">    :arg bath: bathymetry :class: &#39;Function&#39;</span>
<span class="sd">    :arg scalar_func: scalar :class:`Function` to integrate</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">val</span> <span class="o">=</span> <span class="n">assemble</span><span class="p">((</span><span class="n">eta</span><span class="o">+</span><span class="n">bath</span><span class="p">)</span><span class="o">*</span><span class="n">scalar_func</span><span class="o">*</span><span class="n">dx</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">val</span></div>


<div class="viewcode-block" id="comp_tracer_mass_3d"><a class="viewcode-back" href="../../thetis.html#thetis.utility.comp_tracer_mass_3d">[docs]</a><span class="k">def</span> <span class="nf">comp_tracer_mass_3d</span><span class="p">(</span><span class="n">scalar_func</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Computes total tracer mass in the 3D domain</span>

<span class="sd">    :arg scalar_func: scalar :class:`Function` to integrate</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">val</span> <span class="o">=</span> <span class="n">assemble</span><span class="p">(</span><span class="n">scalar_func</span><span class="o">*</span><span class="n">dx</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">val</span></div>


<div class="viewcode-block" id="get_zcoord_from_mesh"><a class="viewcode-back" href="../../thetis.html#thetis.utility.get_zcoord_from_mesh">[docs]</a><span class="k">def</span> <span class="nf">get_zcoord_from_mesh</span><span class="p">(</span><span class="n">zcoord</span><span class="p">,</span> <span class="n">solver_parameters</span><span class="o">=</span><span class="p">{}):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Evaluates z coordinates from the 3D mesh</span>

<span class="sd">    :arg zcoord: scalar :class:`Function` where coordinates will be stored</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1"># TODO coordinates should probably be interpolated instead</span>
    <span class="n">solver_parameters</span><span class="o">.</span><span class="n">setdefault</span><span class="p">(</span><span class="s1">&#39;ksp_atol&#39;</span><span class="p">,</span> <span class="mf">1e-12</span><span class="p">)</span>
    <span class="n">solver_parameters</span><span class="o">.</span><span class="n">setdefault</span><span class="p">(</span><span class="s1">&#39;ksp_rtol&#39;</span><span class="p">,</span> <span class="mf">1e-16</span><span class="p">)</span>
    <span class="n">fs</span> <span class="o">=</span> <span class="n">zcoord</span><span class="o">.</span><span class="n">function_space</span><span class="p">()</span>
    <span class="n">tri</span> <span class="o">=</span> <span class="n">TrialFunction</span><span class="p">(</span><span class="n">fs</span><span class="p">)</span>
    <span class="n">test</span> <span class="o">=</span> <span class="n">TestFunction</span><span class="p">(</span><span class="n">fs</span><span class="p">)</span>
    <span class="n">a</span> <span class="o">=</span> <span class="n">tri</span><span class="o">*</span><span class="n">test</span><span class="o">*</span><span class="n">dx</span>
    <span class="n">l</span> <span class="o">=</span> <span class="n">fs</span><span class="o">.</span><span class="n">mesh</span><span class="p">()</span><span class="o">.</span><span class="n">coordinates</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span><span class="o">*</span><span class="n">test</span><span class="o">*</span><span class="n">dx</span>
    <span class="n">solve</span><span class="p">(</span><span class="n">a</span> <span class="o">==</span> <span class="n">l</span><span class="p">,</span> <span class="n">zcoord</span><span class="p">,</span> <span class="n">solver_parameters</span><span class="o">=</span><span class="n">solver_parameters</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">zcoord</span></div>


<div class="viewcode-block" id="VerticalVelocitySolver"><a class="viewcode-back" href="../../thetis.html#thetis.utility.VerticalVelocitySolver">[docs]</a><span class="k">class</span> <span class="nc">VerticalVelocitySolver</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>
    <span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Computes vertical velocity diagnostically from the continuity equation</span>

<span class="sd">    Vertical velocity is obtained from the continuity equation</span>

<span class="sd">    .. math::</span>
<span class="sd">        \frac{\partial w}{\partial z} = -\nabla_h \cdot \textbf{u}</span>
<span class="sd">        :label: continuity_eq_3d</span>

<span class="sd">    and the bottom impermeability condition (:math:`h` denotes the bathymetry)</span>

<span class="sd">    .. math::</span>
<span class="sd">        \textbf{n}_h \cdot \textbf{u} + w n_z &amp;= 0 \quad \forall \mathbf{x} \in \Gamma_{b} \\</span>
<span class="sd">        \Leftrightarrow w &amp;= -\nabla_h h \cdot \mathbf{u} \quad \forall \mathbf{x} \in \Gamma_{b}</span>

<span class="sd">    :math:`w` can be solved with the weak form</span>

<span class="sd">    .. math::</span>
<span class="sd">        \int_{\Gamma_s} w n_z \varphi dS</span>
<span class="sd">        + \int_{\mathcal{I}_h} \text{avg}(w) \text{jump}(\varphi n_z) dS</span>
<span class="sd">        - \int_{\Omega} w \frac{\partial \varphi}{\partial z} dx</span>
<span class="sd">        = \\</span>
<span class="sd">        \int_{\Omega} \mathbf{u} \cdot \nabla_h \varphi dx</span>
<span class="sd">        - \int_{\mathcal{I}_h \cup \mathcal{I}_v} \text{avg}(\mathbf{u}) \cdot \text{jump}(\varphi \mathbf{n}_h) dS</span>
<span class="sd">        - \int_{\Gamma_s} \mathbf{u} \cdot \varphi \mathbf{n}_h dS</span>

<span class="sd">    where the :math:`\Gamma_b` terms vanish due to the bottom impermeability</span>
<span class="sd">    condition.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">solution</span><span class="p">,</span> <span class="n">uv</span><span class="p">,</span> <span class="n">bathymetry</span><span class="p">,</span> <span class="n">boundary_funcs</span><span class="o">=</span><span class="p">{},</span>
                 <span class="n">solver_parameters</span><span class="o">=</span><span class="p">{}):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        :arg solution: w :class:`Function`</span>
<span class="sd">        :arg uv: horizontal velocity :class:`Function`</span>
<span class="sd">        :arg bathymetry: bathymetry :class:`Function`</span>
<span class="sd">        :kwarg dict boundary_funcs: boundary conditions used in the 3D momentum</span>
<span class="sd">            equation. Provides external values of uv (if any).</span>
<span class="sd">        :kwarg dict solver_parameters: PETSc solver options</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">solver_parameters</span><span class="o">.</span><span class="n">setdefault</span><span class="p">(</span><span class="s1">&#39;snes_type&#39;</span><span class="p">,</span> <span class="s1">&#39;ksponly&#39;</span><span class="p">)</span>
        <span class="n">solver_parameters</span><span class="o">.</span><span class="n">setdefault</span><span class="p">(</span><span class="s1">&#39;ksp_type&#39;</span><span class="p">,</span> <span class="s1">&#39;preonly&#39;</span><span class="p">)</span>
        <span class="n">solver_parameters</span><span class="o">.</span><span class="n">setdefault</span><span class="p">(</span><span class="s1">&#39;pc_type&#39;</span><span class="p">,</span> <span class="s1">&#39;bjacobi&#39;</span><span class="p">)</span>
        <span class="n">solver_parameters</span><span class="o">.</span><span class="n">setdefault</span><span class="p">(</span><span class="s1">&#39;sub_ksp_type&#39;</span><span class="p">,</span> <span class="s1">&#39;preonly&#39;</span><span class="p">)</span>
        <span class="n">solver_parameters</span><span class="o">.</span><span class="n">setdefault</span><span class="p">(</span><span class="s1">&#39;sub_pc_type&#39;</span><span class="p">,</span> <span class="s1">&#39;ilu&#39;</span><span class="p">)</span>
        <span class="n">fs</span> <span class="o">=</span> <span class="n">solution</span><span class="o">.</span><span class="n">function_space</span><span class="p">()</span>
        <span class="n">mesh</span> <span class="o">=</span> <span class="n">fs</span><span class="o">.</span><span class="n">mesh</span><span class="p">()</span>
        <span class="n">test</span> <span class="o">=</span> <span class="n">TestFunction</span><span class="p">(</span><span class="n">fs</span><span class="p">)</span>
        <span class="n">tri</span> <span class="o">=</span> <span class="n">TrialFunction</span><span class="p">(</span><span class="n">fs</span><span class="p">)</span>
        <span class="n">normal</span> <span class="o">=</span> <span class="n">FacetNormal</span><span class="p">(</span><span class="n">mesh</span><span class="p">)</span>

        <span class="c1"># define measures with a reasonable quadrature degree</span>
        <span class="n">p</span><span class="p">,</span> <span class="n">q</span> <span class="o">=</span> <span class="n">fs</span><span class="o">.</span><span class="n">ufl_element</span><span class="p">()</span><span class="o">.</span><span class="n">degree</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">quad_degree</span> <span class="o">=</span> <span class="p">(</span><span class="mi">2</span><span class="o">*</span><span class="n">p</span><span class="p">,</span> <span class="mi">2</span><span class="o">*</span><span class="n">q</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">dx</span> <span class="o">=</span> <span class="n">dx</span><span class="p">(</span><span class="n">degree</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">quad_degree</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">dS_h</span> <span class="o">=</span> <span class="n">dS_h</span><span class="p">(</span><span class="n">degree</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">quad_degree</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">dS_v</span> <span class="o">=</span> <span class="n">dS_v</span><span class="p">(</span><span class="n">degree</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">quad_degree</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">ds_surf</span> <span class="o">=</span> <span class="n">ds_surf</span><span class="p">(</span><span class="n">degree</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">quad_degree</span><span class="p">)</span>

        <span class="c1"># NOTE weak dw/dz</span>
        <span class="n">a</span> <span class="o">=</span> <span class="n">tri</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span><span class="o">*</span><span class="n">test</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span><span class="o">*</span><span class="n">normal</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span><span class="o">*</span><span class="n">ds_surf</span> <span class="o">+</span> \
            <span class="n">avg</span><span class="p">(</span><span class="n">tri</span><span class="p">[</span><span class="mi">2</span><span class="p">])</span><span class="o">*</span><span class="n">jump</span><span class="p">(</span><span class="n">test</span><span class="p">[</span><span class="mi">2</span><span class="p">],</span> <span class="n">normal</span><span class="p">[</span><span class="mi">2</span><span class="p">])</span><span class="o">*</span><span class="n">dS_h</span> <span class="o">-</span> <span class="n">Dx</span><span class="p">(</span><span class="n">test</span><span class="p">[</span><span class="mi">2</span><span class="p">],</span> <span class="mi">2</span><span class="p">)</span><span class="o">*</span><span class="n">tri</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span><span class="o">*</span><span class="bp">self</span><span class="o">.</span><span class="n">dx</span>

        <span class="c1"># NOTE weak div(uv)</span>
        <span class="n">uv_star</span> <span class="o">=</span> <span class="n">avg</span><span class="p">(</span><span class="n">uv</span><span class="p">)</span>
        <span class="c1"># NOTE in the case of mimetic uv the div must be taken over all components</span>
        <span class="n">l</span> <span class="o">=</span> <span class="p">(</span><span class="n">inner</span><span class="p">(</span><span class="n">uv</span><span class="p">,</span> <span class="n">nabla_grad</span><span class="p">(</span><span class="n">test</span><span class="p">[</span><span class="mi">2</span><span class="p">]))</span><span class="o">*</span><span class="bp">self</span><span class="o">.</span><span class="n">dx</span> <span class="o">-</span>
             <span class="p">(</span><span class="n">uv_star</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">*</span><span class="n">jump</span><span class="p">(</span><span class="n">test</span><span class="p">[</span><span class="mi">2</span><span class="p">],</span> <span class="n">normal</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span> <span class="o">+</span>
              <span class="n">uv_star</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">*</span><span class="n">jump</span><span class="p">(</span><span class="n">test</span><span class="p">[</span><span class="mi">2</span><span class="p">],</span> <span class="n">normal</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span> <span class="o">+</span>
              <span class="n">uv_star</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span><span class="o">*</span><span class="n">jump</span><span class="p">(</span><span class="n">test</span><span class="p">[</span><span class="mi">2</span><span class="p">],</span> <span class="n">normal</span><span class="p">[</span><span class="mi">2</span><span class="p">])</span>
              <span class="p">)</span><span class="o">*</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">dS_v</span><span class="p">)</span> <span class="o">-</span>
             <span class="p">(</span><span class="n">uv_star</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">*</span><span class="n">jump</span><span class="p">(</span><span class="n">test</span><span class="p">[</span><span class="mi">2</span><span class="p">],</span> <span class="n">normal</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span> <span class="o">+</span>
              <span class="n">uv_star</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">*</span><span class="n">jump</span><span class="p">(</span><span class="n">test</span><span class="p">[</span><span class="mi">2</span><span class="p">],</span> <span class="n">normal</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span> <span class="o">+</span>
              <span class="n">uv_star</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span><span class="o">*</span><span class="n">jump</span><span class="p">(</span><span class="n">test</span><span class="p">[</span><span class="mi">2</span><span class="p">],</span> <span class="n">normal</span><span class="p">[</span><span class="mi">2</span><span class="p">])</span>
              <span class="p">)</span><span class="o">*</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">dS_h</span><span class="p">)</span> <span class="o">-</span>
             <span class="p">(</span><span class="n">uv</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">*</span><span class="n">normal</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">+</span>
              <span class="n">uv</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">*</span><span class="n">normal</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">+</span>
              <span class="n">uv</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span><span class="o">*</span><span class="n">normal</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span>
              <span class="p">)</span><span class="o">*</span><span class="n">test</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span><span class="o">*</span><span class="bp">self</span><span class="o">.</span><span class="n">ds_surf</span>
             <span class="p">)</span>
        <span class="k">for</span> <span class="n">bnd_marker</span> <span class="ow">in</span> <span class="nb">sorted</span><span class="p">(</span><span class="n">mesh</span><span class="o">.</span><span class="n">exterior_facets</span><span class="o">.</span><span class="n">unique_markers</span><span class="p">):</span>
            <span class="n">funcs</span> <span class="o">=</span> <span class="n">boundary_funcs</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">bnd_marker</span><span class="p">)</span>
            <span class="n">ds_bnd</span> <span class="o">=</span> <span class="n">ds_v</span><span class="p">(</span><span class="nb">int</span><span class="p">(</span><span class="n">bnd_marker</span><span class="p">),</span> <span class="n">degree</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">quad_degree</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">funcs</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="c1"># assume land boundary</span>
                <span class="k">continue</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="c1"># use symmetry condition</span>
                <span class="n">l</span> <span class="o">+=</span> <span class="o">-</span><span class="p">(</span><span class="n">uv</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">*</span><span class="n">normal</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">+</span> <span class="n">uv</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">*</span><span class="n">normal</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span><span class="o">*</span><span class="n">test</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span><span class="o">*</span><span class="n">ds_bnd</span>

        <span class="c1"># NOTE For ALE mesh constant_jacobian should be False</span>
        <span class="c1"># however the difference is very small as A is nearly independent of</span>
        <span class="c1"># mesh stretching: only the normals vary in time</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">prob</span> <span class="o">=</span> <span class="n">LinearVariationalProblem</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">l</span><span class="p">,</span> <span class="n">solution</span><span class="p">,</span>
                                             <span class="n">constant_jacobian</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">solver</span> <span class="o">=</span> <span class="n">LinearVariationalSolver</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">prob</span><span class="p">,</span>
                                              <span class="n">solver_parameters</span><span class="o">=</span><span class="n">solver_parameters</span><span class="p">)</span>

<div class="viewcode-block" id="VerticalVelocitySolver.solve"><a class="viewcode-back" href="../../thetis.html#thetis.utility.VerticalVelocitySolver.solve">[docs]</a>    <span class="k">def</span> <span class="nf">solve</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Compute w&quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">solver</span><span class="o">.</span><span class="n">solve</span><span class="p">()</span></div></div>


<div class="viewcode-block" id="VerticalIntegrator"><a class="viewcode-back" href="../../thetis.html#thetis.utility.VerticalIntegrator">[docs]</a><span class="k">class</span> <span class="nc">VerticalIntegrator</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Computes vertical integral (or average) of a field.</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="nb">input</span><span class="p">,</span> <span class="n">output</span><span class="p">,</span> <span class="n">bottom_to_top</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
                 <span class="n">bnd_value</span><span class="o">=</span><span class="n">Constant</span><span class="p">(</span><span class="mf">0.0</span><span class="p">),</span> <span class="n">average</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
                 <span class="n">bathymetry</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">elevation</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">solver_parameters</span><span class="o">=</span><span class="p">{}):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        :arg input: 3D field to integrate</span>
<span class="sd">        :arg output: 3D field where the integral is stored</span>
<span class="sd">        :kwarg bottom_to_top: Defines the integration direction: If True integration is performed along the z axis, from bottom surface to top surface.</span>
<span class="sd">        :kwarg bnd_value: Value of the integral at the bottom (top) boundary if bottom_to_top is True (False)</span>
<span class="sd">        :kwarg average: If True computes the vertical average instead. Requires bathymetry and elevation fields</span>
<span class="sd">        :kwarg bathymetry: 3D field defining the bathymetry</span>
<span class="sd">        :kwarg elevation: 3D field defining the free surface elevation</span>
<span class="sd">        :kwarg dict solver_parameters: PETSc solver options</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">solver_parameters</span><span class="o">.</span><span class="n">setdefault</span><span class="p">(</span><span class="s1">&#39;snes_type&#39;</span><span class="p">,</span> <span class="s1">&#39;ksponly&#39;</span><span class="p">)</span>
        <span class="n">solver_parameters</span><span class="o">.</span><span class="n">setdefault</span><span class="p">(</span><span class="s1">&#39;ksp_type&#39;</span><span class="p">,</span> <span class="s1">&#39;preonly&#39;</span><span class="p">)</span>
        <span class="n">solver_parameters</span><span class="o">.</span><span class="n">setdefault</span><span class="p">(</span><span class="s1">&#39;pc_type&#39;</span><span class="p">,</span> <span class="s1">&#39;bjacobi&#39;</span><span class="p">)</span>
        <span class="n">solver_parameters</span><span class="o">.</span><span class="n">setdefault</span><span class="p">(</span><span class="s1">&#39;sub_ksp_type&#39;</span><span class="p">,</span> <span class="s1">&#39;preonly&#39;</span><span class="p">)</span>
        <span class="n">solver_parameters</span><span class="o">.</span><span class="n">setdefault</span><span class="p">(</span><span class="s1">&#39;sub_pc_type&#39;</span><span class="p">,</span> <span class="s1">&#39;ilu&#39;</span><span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">output</span> <span class="o">=</span> <span class="n">output</span>
        <span class="n">space</span> <span class="o">=</span> <span class="n">output</span><span class="o">.</span><span class="n">function_space</span><span class="p">()</span>
        <span class="n">mesh</span> <span class="o">=</span> <span class="n">space</span><span class="o">.</span><span class="n">mesh</span><span class="p">()</span>
        <span class="n">vertical_is_dg</span> <span class="o">=</span> <span class="n">element_continuity</span><span class="p">(</span><span class="n">space</span><span class="o">.</span><span class="n">ufl_element</span><span class="p">())</span><span class="o">.</span><span class="n">vertical</span> <span class="ow">in</span> <span class="p">[</span><span class="s1">&#39;dg&#39;</span><span class="p">,</span> <span class="s1">&#39;hdiv&#39;</span><span class="p">]</span>
        <span class="n">tri</span> <span class="o">=</span> <span class="n">TrialFunction</span><span class="p">(</span><span class="n">space</span><span class="p">)</span>
        <span class="n">phi</span> <span class="o">=</span> <span class="n">TestFunction</span><span class="p">(</span><span class="n">space</span><span class="p">)</span>
        <span class="n">normal</span> <span class="o">=</span> <span class="n">FacetNormal</span><span class="p">(</span><span class="n">mesh</span><span class="p">)</span>

        <span class="c1"># define measures with a reasonable quadrature degree</span>
        <span class="n">p</span><span class="p">,</span> <span class="n">q</span> <span class="o">=</span> <span class="n">space</span><span class="o">.</span><span class="n">ufl_element</span><span class="p">()</span><span class="o">.</span><span class="n">degree</span><span class="p">()</span>
        <span class="n">p_in</span><span class="p">,</span> <span class="n">q_in</span> <span class="o">=</span> <span class="nb">input</span><span class="o">.</span><span class="n">function_space</span><span class="p">()</span><span class="o">.</span><span class="n">ufl_element</span><span class="p">()</span><span class="o">.</span><span class="n">degree</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">quad_degree</span> <span class="o">=</span> <span class="p">(</span><span class="n">p</span><span class="o">+</span><span class="n">p_in</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span> <span class="n">q</span><span class="o">+</span><span class="n">q_in</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">dx</span> <span class="o">=</span> <span class="n">dx</span><span class="p">(</span><span class="n">degree</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">quad_degree</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">dS_h</span> <span class="o">=</span> <span class="n">dS_h</span><span class="p">(</span><span class="n">degree</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">quad_degree</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">ds_surf</span> <span class="o">=</span> <span class="n">ds_surf</span><span class="p">(</span><span class="n">degree</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">quad_degree</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">ds_bottom</span> <span class="o">=</span> <span class="n">ds_bottom</span><span class="p">(</span><span class="n">degree</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">quad_degree</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">bottom_to_top</span><span class="p">:</span>
            <span class="n">bnd_term</span> <span class="o">=</span> <span class="n">normal</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span><span class="o">*</span><span class="n">inner</span><span class="p">(</span><span class="n">bnd_value</span><span class="p">,</span> <span class="n">phi</span><span class="p">)</span><span class="o">*</span><span class="bp">self</span><span class="o">.</span><span class="n">ds_bottom</span>
            <span class="n">mass_bnd_term</span> <span class="o">=</span> <span class="n">normal</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span><span class="o">*</span><span class="n">inner</span><span class="p">(</span><span class="n">tri</span><span class="p">,</span> <span class="n">phi</span><span class="p">)</span><span class="o">*</span><span class="bp">self</span><span class="o">.</span><span class="n">ds_surf</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">bnd_term</span> <span class="o">=</span> <span class="n">normal</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span><span class="o">*</span><span class="n">inner</span><span class="p">(</span><span class="n">bnd_value</span><span class="p">,</span> <span class="n">phi</span><span class="p">)</span><span class="o">*</span><span class="bp">self</span><span class="o">.</span><span class="n">ds_surf</span>
            <span class="n">mass_bnd_term</span> <span class="o">=</span> <span class="n">normal</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span><span class="o">*</span><span class="n">inner</span><span class="p">(</span><span class="n">tri</span><span class="p">,</span> <span class="n">phi</span><span class="p">)</span><span class="o">*</span><span class="bp">self</span><span class="o">.</span><span class="n">ds_bottom</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">a</span> <span class="o">=</span> <span class="o">-</span><span class="n">inner</span><span class="p">(</span><span class="n">Dx</span><span class="p">(</span><span class="n">phi</span><span class="p">,</span> <span class="mi">2</span><span class="p">),</span> <span class="n">tri</span><span class="p">)</span><span class="o">*</span><span class="bp">self</span><span class="o">.</span><span class="n">dx</span> <span class="o">+</span> <span class="n">mass_bnd_term</span>
        <span class="k">if</span> <span class="n">bottom_to_top</span><span class="p">:</span>
            <span class="n">up_value</span> <span class="o">=</span> <span class="n">tri</span><span class="p">(</span><span class="s1">&#39;+&#39;</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">up_value</span> <span class="o">=</span> <span class="n">tri</span><span class="p">(</span><span class="s1">&#39;-&#39;</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">vertical_is_dg</span><span class="p">:</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="nb">input</span><span class="o">.</span><span class="n">ufl_shape</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
                <span class="n">dim</span> <span class="o">=</span> <span class="nb">input</span><span class="o">.</span><span class="n">ufl_shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
                <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">dim</span><span class="p">):</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">a</span> <span class="o">+=</span> <span class="n">up_value</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">*</span><span class="n">jump</span><span class="p">(</span><span class="n">phi</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">normal</span><span class="p">[</span><span class="mi">2</span><span class="p">])</span><span class="o">*</span><span class="bp">self</span><span class="o">.</span><span class="n">dS_h</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">a</span> <span class="o">+=</span> <span class="n">up_value</span><span class="o">*</span><span class="n">jump</span><span class="p">(</span><span class="n">phi</span><span class="p">,</span> <span class="n">normal</span><span class="p">[</span><span class="mi">2</span><span class="p">])</span><span class="o">*</span><span class="bp">self</span><span class="o">.</span><span class="n">dS_h</span>
        <span class="k">if</span> <span class="n">average</span><span class="p">:</span>
            <span class="n">source</span> <span class="o">=</span> <span class="nb">input</span><span class="o">/</span><span class="p">(</span><span class="n">elevation</span> <span class="o">+</span> <span class="n">bathymetry</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">source</span> <span class="o">=</span> <span class="nb">input</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">l</span> <span class="o">=</span> <span class="n">inner</span><span class="p">(</span><span class="n">source</span><span class="p">,</span> <span class="n">phi</span><span class="p">)</span><span class="o">*</span><span class="bp">self</span><span class="o">.</span><span class="n">dx</span> <span class="o">+</span> <span class="n">bnd_term</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">prob</span> <span class="o">=</span> <span class="n">LinearVariationalProblem</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">a</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">l</span><span class="p">,</span> <span class="n">output</span><span class="p">,</span> <span class="n">constant_jacobian</span><span class="o">=</span><span class="n">average</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">solver</span> <span class="o">=</span> <span class="n">LinearVariationalSolver</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">prob</span><span class="p">,</span> <span class="n">solver_parameters</span><span class="o">=</span><span class="n">solver_parameters</span><span class="p">)</span>

<div class="viewcode-block" id="VerticalIntegrator.solve"><a class="viewcode-back" href="../../thetis.html#thetis.utility.VerticalIntegrator.solve">[docs]</a>    <span class="k">def</span> <span class="nf">solve</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Computes the integral and stores it in the output field.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">solver</span><span class="o">.</span><span class="n">solve</span><span class="p">()</span></div></div>


<div class="viewcode-block" id="DensitySolver"><a class="viewcode-back" href="../../thetis.html#thetis.utility.DensitySolver">[docs]</a><span class="k">class</span> <span class="nc">DensitySolver</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>
    <span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Computes density from salinity and temperature using the equation of state.</span>

<span class="sd">    Water density is defined as</span>

<span class="sd">    .. math::</span>
<span class="sd">        \rho = \rho&#39;(T, S, p) + \rho_0</span>

<span class="sd">    This method computes the density anomaly :math:`\rho&#39;`.</span>

<span class="sd">    Density is computed point-wise assuming that temperature, salinity and</span>
<span class="sd">    density are in the same function space.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">salinity</span><span class="p">,</span> <span class="n">temperature</span><span class="p">,</span> <span class="n">density</span><span class="p">,</span> <span class="n">eos_class</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        :arg salinity: water salinity field</span>
<span class="sd">        :type salinity: :class:`Function`</span>
<span class="sd">        :arg temperature: water temperature field</span>
<span class="sd">        :type temperature: :class:`Function`</span>
<span class="sd">        :arg density: water density field</span>
<span class="sd">        :type density: :class:`Function`</span>
<span class="sd">        :arg eos_class: equation of state that defines water density</span>
<span class="sd">        :type eos_class: :class:`EquationOfState`</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">fs</span> <span class="o">=</span> <span class="n">density</span><span class="o">.</span><span class="n">function_space</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">eos</span> <span class="o">=</span> <span class="n">eos_class</span>

        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">salinity</span><span class="p">,</span> <span class="n">FiredrakeFunction</span><span class="p">):</span>
            <span class="k">assert</span> <span class="bp">self</span><span class="o">.</span><span class="n">fs</span> <span class="o">==</span> <span class="n">salinity</span><span class="o">.</span><span class="n">function_space</span><span class="p">()</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">temperature</span><span class="p">,</span> <span class="n">FiredrakeFunction</span><span class="p">):</span>
            <span class="k">assert</span> <span class="bp">self</span><span class="o">.</span><span class="n">fs</span> <span class="o">==</span> <span class="n">temperature</span><span class="o">.</span><span class="n">function_space</span><span class="p">()</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">s</span> <span class="o">=</span> <span class="n">salinity</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">t</span> <span class="o">=</span> <span class="n">temperature</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">rho</span> <span class="o">=</span> <span class="n">density</span>

    <span class="k">def</span> <span class="nf">_get_array</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">function</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Returns numpy data array from a :class:`Function`&quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">function</span><span class="p">,</span> <span class="n">FiredrakeFunction</span><span class="p">):</span>
            <span class="k">assert</span> <span class="bp">self</span><span class="o">.</span><span class="n">fs</span> <span class="o">==</span> <span class="n">function</span><span class="o">.</span><span class="n">function_space</span><span class="p">()</span>
            <span class="k">return</span> <span class="n">function</span><span class="o">.</span><span class="n">dat</span><span class="o">.</span><span class="n">data</span><span class="p">[:]</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">function</span><span class="p">,</span> <span class="n">FiredrakeConstant</span><span class="p">):</span>
            <span class="k">return</span> <span class="n">function</span><span class="o">.</span><span class="n">dat</span><span class="o">.</span><span class="n">data</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="c1"># assume that function is a float</span>
        <span class="k">return</span> <span class="n">function</span>

<div class="viewcode-block" id="DensitySolver.solve"><a class="viewcode-back" href="../../thetis.html#thetis.utility.DensitySolver.solve">[docs]</a>    <span class="k">def</span> <span class="nf">solve</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Compute density&quot;&quot;&quot;</span>
        <span class="n">s</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_array</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">s</span><span class="p">)</span>
        <span class="n">th</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_array</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">t</span><span class="p">)</span>
        <span class="n">p</span> <span class="o">=</span> <span class="mf">0.0</span>  <span class="c1"># NOTE ignore pressure for now</span>
        <span class="n">rho0</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_array</span><span class="p">(</span><span class="n">physical_constants</span><span class="p">[</span><span class="s1">&#39;rho0&#39;</span><span class="p">])</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">rho</span><span class="o">.</span><span class="n">dat</span><span class="o">.</span><span class="n">data</span><span class="p">[:]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">eos</span><span class="o">.</span><span class="n">compute_rho</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="n">th</span><span class="p">,</span> <span class="n">p</span><span class="p">,</span> <span class="n">rho0</span><span class="p">)</span></div></div>


<div class="viewcode-block" id="DensitySolverWeak"><a class="viewcode-back" href="../../thetis.html#thetis.utility.DensitySolverWeak">[docs]</a><span class="k">class</span> <span class="nc">DensitySolverWeak</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>
    <span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Computes density from salinity and temperature using the equation of state.</span>

<span class="sd">    Water density is defined as</span>

<span class="sd">    .. math::</span>
<span class="sd">        \rho = \rho&#39;(T, S, p) + \rho_0</span>

<span class="sd">    This method computes the density anomaly :math:`\rho&#39;`.</span>

<span class="sd">    Density is computed in a weak sense by projecting the analytical expression</span>
<span class="sd">    on the density field.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">salinity</span><span class="p">,</span> <span class="n">temperature</span><span class="p">,</span> <span class="n">density</span><span class="p">,</span> <span class="n">eos_class</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        :arg salinity: water salinity field</span>
<span class="sd">        :type salinity: :class:`Function`</span>
<span class="sd">        :arg temperature: water temperature field</span>
<span class="sd">        :type temperature: :class:`Function`</span>
<span class="sd">        :arg density: water density field</span>
<span class="sd">        :type density: :class:`Function`</span>
<span class="sd">        :arg eos_class: equation of state that defines water density</span>
<span class="sd">        :type eos_class: :class:`EquationOfState`</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">fs</span> <span class="o">=</span> <span class="n">density</span><span class="o">.</span><span class="n">function_space</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">eos</span> <span class="o">=</span> <span class="n">eos_class</span>

        <span class="k">assert</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">salinity</span><span class="p">,</span> <span class="p">(</span><span class="n">FiredrakeFunction</span><span class="p">,</span> <span class="n">FiredrakeConstant</span><span class="p">))</span>
        <span class="k">assert</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">temperature</span><span class="p">,</span> <span class="p">(</span><span class="n">FiredrakeFunction</span><span class="p">,</span> <span class="n">FiredrakeConstant</span><span class="p">))</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">s</span> <span class="o">=</span> <span class="n">salinity</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">t</span> <span class="o">=</span> <span class="n">temperature</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">density</span> <span class="o">=</span> <span class="n">density</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">p</span> <span class="o">=</span> <span class="n">Constant</span><span class="p">(</span><span class="mf">0.</span><span class="p">)</span>
        <span class="n">rho0</span> <span class="o">=</span> <span class="n">physical_constants</span><span class="p">[</span><span class="s1">&#39;rho0&#39;</span><span class="p">]</span>

        <span class="n">f</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">eos</span><span class="o">.</span><span class="n">eval</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">s</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">t</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">p</span><span class="p">,</span> <span class="n">rho0</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">projector</span> <span class="o">=</span> <span class="n">Projector</span><span class="p">(</span><span class="n">f</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">density</span><span class="p">)</span>

<div class="viewcode-block" id="DensitySolverWeak.ensure_positive_salinity"><a class="viewcode-back" href="../../thetis.html#thetis.utility.DensitySolverWeak.ensure_positive_salinity">[docs]</a>    <span class="k">def</span> <span class="nf">ensure_positive_salinity</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        make sure salinity is not negative</span>

<span class="sd">        some EOS depend on sqrt(salt).</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># FIXME this is really hacky and modifies the state variable</span>
        <span class="c1"># NOTE if salt field is P2 checking nodal values is not enough ..</span>
        <span class="n">ix</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">s</span><span class="o">.</span><span class="n">dat</span><span class="o">.</span><span class="n">data</span> <span class="o">&lt;</span> <span class="mi">0</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">s</span><span class="o">.</span><span class="n">dat</span><span class="o">.</span><span class="n">data</span><span class="p">[</span><span class="n">ix</span><span class="p">]</span> <span class="o">=</span> <span class="mf">0.0</span></div>

<div class="viewcode-block" id="DensitySolverWeak.solve"><a class="viewcode-back" href="../../thetis.html#thetis.utility.DensitySolverWeak.solve">[docs]</a>    <span class="k">def</span> <span class="nf">solve</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Compute density&quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">ensure_positive_salinity</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">projector</span><span class="o">.</span><span class="n">project</span><span class="p">()</span></div></div>


<div class="viewcode-block" id="compute_baroclinic_head"><a class="viewcode-back" href="../../thetis.html#thetis.utility.compute_baroclinic_head">[docs]</a><span class="k">def</span> <span class="nf">compute_baroclinic_head</span><span class="p">(</span><span class="n">solver</span><span class="p">):</span>
    <span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Computes the baroclinic head :math:`r` from the density field</span>

<span class="sd">    .. math::</span>
<span class="sd">        r = \frac{1}{\rho_0} \int_{z}^\eta  \rho&#39; d\zeta.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">with</span> <span class="n">timed_stage</span><span class="p">(</span><span class="s1">&#39;density_solve&#39;</span><span class="p">):</span>
        <span class="n">solver</span><span class="o">.</span><span class="n">density_solver</span><span class="o">.</span><span class="n">solve</span><span class="p">()</span>
    <span class="k">with</span> <span class="n">timed_stage</span><span class="p">(</span><span class="s1">&#39;rho_integral&#39;</span><span class="p">):</span>
        <span class="n">solver</span><span class="o">.</span><span class="n">rho_integrator</span><span class="o">.</span><span class="n">solve</span><span class="p">()</span>
        <span class="n">solver</span><span class="o">.</span><span class="n">fields</span><span class="o">.</span><span class="n">baroc_head_3d</span> <span class="o">*=</span> <span class="o">-</span><span class="n">physical_constants</span><span class="p">[</span><span class="s1">&#39;rho0_inv&#39;</span><span class="p">]</span>
    <span class="k">with</span> <span class="n">timed_stage</span><span class="p">(</span><span class="s1">&#39;int_pg_solve&#39;</span><span class="p">):</span>
        <span class="n">solver</span><span class="o">.</span><span class="n">int_pg_calculator</span><span class="o">.</span><span class="n">solve</span><span class="p">()</span></div>


<div class="viewcode-block" id="VelocityMagnitudeSolver"><a class="viewcode-back" href="../../thetis.html#thetis.utility.VelocityMagnitudeSolver">[docs]</a><span class="k">class</span> <span class="nc">VelocityMagnitudeSolver</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Computes magnitude of (u[0],u[1],w) and stores it in solution</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">solution</span><span class="p">,</span> <span class="n">u</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">w</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">min_val</span><span class="o">=</span><span class="mf">1e-6</span><span class="p">,</span>
                 <span class="n">solver_parameters</span><span class="o">=</span><span class="p">{}):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        :arg solution: scalar field for velocity magnitude scalar :class:`Function`</span>
<span class="sd">        :type solution: :class:`Function`</span>
<span class="sd">        :kwarg u: horizontal velocity</span>
<span class="sd">        :type u: :class:`Function`</span>
<span class="sd">        :kwarg w: vertical velocity</span>
<span class="sd">        :type w: :class:`Function`</span>
<span class="sd">        :kwarg float min_val: minimum value of magnitude. Minimum value of solution</span>
<span class="sd">            will be clipped to this value</span>
<span class="sd">        :kwarg dict solver_parameters: PETSc solver options</span>


<span class="sd">        If ``u`` is None computes magnitude of (0,0,w).</span>

<span class="sd">        If ``w`` is None computes magnitude of (u[0],u[1],0).</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">solution</span> <span class="o">=</span> <span class="n">solution</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">min_val</span> <span class="o">=</span> <span class="n">min_val</span>
        <span class="n">function_space</span> <span class="o">=</span> <span class="n">solution</span><span class="o">.</span><span class="n">function_space</span><span class="p">()</span>
        <span class="n">test</span> <span class="o">=</span> <span class="n">TestFunction</span><span class="p">(</span><span class="n">function_space</span><span class="p">)</span>
        <span class="n">tri</span> <span class="o">=</span> <span class="n">TrialFunction</span><span class="p">(</span><span class="n">function_space</span><span class="p">)</span>

        <span class="n">a</span> <span class="o">=</span> <span class="n">test</span><span class="o">*</span><span class="n">tri</span><span class="o">*</span><span class="n">dx</span>
        <span class="n">s</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="k">if</span> <span class="n">u</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">s</span> <span class="o">+=</span> <span class="n">u</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">**</span><span class="mi">2</span> <span class="o">+</span> <span class="n">u</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">**</span><span class="mi">2</span>
        <span class="k">if</span> <span class="n">w</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">s</span> <span class="o">+=</span> <span class="n">w</span><span class="o">**</span><span class="mi">2</span>
        <span class="n">l</span> <span class="o">=</span> <span class="n">test</span><span class="o">*</span><span class="n">sqrt</span><span class="p">(</span><span class="n">s</span><span class="p">)</span><span class="o">*</span><span class="n">dx</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">prob</span> <span class="o">=</span> <span class="n">LinearVariationalProblem</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">l</span><span class="p">,</span> <span class="n">solution</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">solver</span> <span class="o">=</span> <span class="n">LinearVariationalSolver</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">prob</span><span class="p">,</span> <span class="n">solver_parameters</span><span class="o">=</span><span class="n">solver_parameters</span><span class="p">)</span>

<div class="viewcode-block" id="VelocityMagnitudeSolver.solve"><a class="viewcode-back" href="../../thetis.html#thetis.utility.VelocityMagnitudeSolver.solve">[docs]</a>    <span class="k">def</span> <span class="nf">solve</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Compute the magnitude&quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">solver</span><span class="o">.</span><span class="n">solve</span><span class="p">()</span>
        <span class="n">np</span><span class="o">.</span><span class="n">maximum</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">solution</span><span class="o">.</span><span class="n">dat</span><span class="o">.</span><span class="n">data</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">min_val</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">solution</span><span class="o">.</span><span class="n">dat</span><span class="o">.</span><span class="n">data</span><span class="p">)</span></div></div>


<div class="viewcode-block" id="Mesh3DConsistencyCalculator"><a class="viewcode-back" href="../../thetis.html#thetis.utility.Mesh3DConsistencyCalculator">[docs]</a><span class="k">class</span> <span class="nc">Mesh3DConsistencyCalculator</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>
    <span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Computes a hydrostatic consistency criterion metric on the 3D mesh.</span>

<span class="sd">    Let :math:`\Delta x` and :math:`\Delta z` denote the horizontal and vertical</span>
<span class="sd">    element sizes. The hydrostatic consistency criterion (HCC) can then be</span>
<span class="sd">    expressed as</span>

<span class="sd">    .. math::</span>
<span class="sd">        R = \frac{|\nabla h| \Delta x}{\Delta z} &lt; 1</span>

<span class="sd">    where :math:`\nabla h` is the bathymetry gradient (or gradient of the</span>
<span class="sd">    internal horizontal facet).</span>

<span class="sd">    Violating the hydrostatic consistency criterion leads to internal pressure</span>
<span class="sd">    gradient errors.</span>
<span class="sd">    In practice one can violate the :math:`R &lt; 1` condition without</span>
<span class="sd">    jeopardizing numerical stability; typically :math:`R &lt; 5`.</span>
<span class="sd">    Mesh consistency can be improved by coarsening the vertical</span>
<span class="sd">    mesh, refining the horizontal mesh, or smoothing the bathymetry.</span>

<span class="sd">    For a 3D prism, let :math:`\delta z_t,\delta z_b` denote the maximal</span>
<span class="sd">    :math:`z` coordinate difference in the surface and bottom facets,</span>
<span class="sd">    respectively, and :math:`\Delta z` the height of the prism.</span>
<span class="sd">    We can then compute :math:`R` for the two facets as</span>

<span class="sd">    .. math::</span>
<span class="sd">        R_t &amp;= \frac{\delta z_t}{\Delta z} \\</span>
<span class="sd">        R_b &amp;= \frac{\delta z_b}{\Delta z}</span>

<span class="sd">    For a straight prism we have :math:`R = 0`, and :math:`R = 1` in</span>
<span class="sd">    the case where the highest bottom node is at the same level as the lowest</span>
<span class="sd">    surface node.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">solver_obj</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        :arg solver_obj: :class:`FlowSolver` object</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">solver_obj</span> <span class="o">=</span> <span class="n">solver_obj</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">output</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">solver_obj</span><span class="o">.</span><span class="n">fields</span><span class="o">.</span><span class="n">hcc_metric_3d</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">z_coord</span> <span class="o">=</span> <span class="n">solver_obj</span><span class="o">.</span><span class="n">fields</span><span class="o">.</span><span class="n">z_coord_3d</span>

        <span class="c1"># create par loop for computing delta</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">fs_3d</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">solver_obj</span><span class="o">.</span><span class="n">function_spaces</span><span class="o">.</span><span class="n">P1DG</span>
        <span class="k">assert</span> <span class="bp">self</span><span class="o">.</span><span class="n">output</span><span class="o">.</span><span class="n">function_space</span><span class="p">()</span> <span class="o">==</span> <span class="bp">self</span><span class="o">.</span><span class="n">fs_3d</span>

        <span class="n">nodes</span> <span class="o">=</span> <span class="n">get_facet_mask</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">fs_3d</span><span class="p">,</span> <span class="s1">&#39;geometric&#39;</span><span class="p">,</span> <span class="s1">&#39;bottom&#39;</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">idx</span> <span class="o">=</span> <span class="n">op2</span><span class="o">.</span><span class="n">Global</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">nodes</span><span class="p">),</span> <span class="n">nodes</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">int32</span><span class="p">,</span> <span class="n">name</span><span class="o">=</span><span class="s1">&#39;node_idx&#39;</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">kernel</span> <span class="o">=</span> <span class="n">op2</span><span class="o">.</span><span class="n">Kernel</span><span class="p">(</span><span class="s2">&quot;&quot;&quot;</span>
<span class="s2">            void my_kernel(double **output, double **z_field, int *idx) {</span>
<span class="s2">                // compute max delta z on top and bottom facets</span>
<span class="s2">                double z_top_max = -1e20;</span>
<span class="s2">                double z_top_min = 1e20;</span>
<span class="s2">                double z_bot_max = -1e20;</span>
<span class="s2">                double z_bot_min = 1e20;</span>
<span class="s2">                int i_top = 1;</span>
<span class="s2">                int i_bot = 0;</span>
<span class="s2">                for ( int d = 0; d &lt; </span><span class="si">%(nodes)d</span><span class="s2">; d++ ) {</span>
<span class="s2">                    double z_top = z_field[idx[d] + i_top][0];</span>
<span class="s2">                    double z_bot = z_field[idx[d] + i_bot][0];</span>
<span class="s2">                    z_top_max = fmax(z_top, z_top_max);</span>
<span class="s2">                    z_top_min = fmin(z_top, z_top_min);</span>
<span class="s2">                    z_bot_max = fmax(z_bot, z_bot_max);</span>
<span class="s2">                    z_bot_min = fmin(z_bot, z_bot_min);</span>
<span class="s2">                }</span>
<span class="s2">                double delta_z_top = z_top_max - z_top_min;</span>
<span class="s2">                double delta_z_bot = z_bot_max - z_bot_min;</span>
<span class="s2">                // compute R ratio</span>
<span class="s2">                for ( int d = 0; d &lt; </span><span class="si">%(nodes)d</span><span class="s2">; d++ ) {</span>
<span class="s2">                    double z_top = z_field[idx[d] + i_top][0];</span>
<span class="s2">                    double z_bot = z_field[idx[d] + i_bot][0];</span>
<span class="s2">                    double h = z_top - z_bot;</span>
<span class="s2">                    output[idx[d] + i_top][0] = delta_z_top/h;</span>
<span class="s2">                    output[idx[d] + i_bot][0] = delta_z_bot/h;</span>
<span class="s2">                }</span>
<span class="s2">            }&quot;&quot;&quot;</span> <span class="o">%</span> <span class="p">{</span><span class="s1">&#39;nodes&#39;</span><span class="p">:</span> <span class="nb">len</span><span class="p">(</span><span class="n">nodes</span><span class="p">)},</span>
            <span class="s1">&#39;my_kernel&#39;</span><span class="p">)</span>

<div class="viewcode-block" id="Mesh3DConsistencyCalculator.solve"><a class="viewcode-back" href="../../thetis.html#thetis.utility.Mesh3DConsistencyCalculator.solve">[docs]</a>    <span class="k">def</span> <span class="nf">solve</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Compute the HCC metric&quot;&quot;&quot;</span>
        <span class="n">op2</span><span class="o">.</span><span class="n">par_loop</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">kernel</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">solver_obj</span><span class="o">.</span><span class="n">mesh</span><span class="o">.</span><span class="n">cell_set</span><span class="p">,</span>
                     <span class="bp">self</span><span class="o">.</span><span class="n">output</span><span class="o">.</span><span class="n">dat</span><span class="p">(</span><span class="n">op2</span><span class="o">.</span><span class="n">WRITE</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">output</span><span class="o">.</span><span class="n">function_space</span><span class="p">()</span><span class="o">.</span><span class="n">cell_node_map</span><span class="p">()),</span>
                     <span class="bp">self</span><span class="o">.</span><span class="n">z_coord</span><span class="o">.</span><span class="n">dat</span><span class="p">(</span><span class="n">op2</span><span class="o">.</span><span class="n">READ</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">z_coord</span><span class="o">.</span><span class="n">function_space</span><span class="p">()</span><span class="o">.</span><span class="n">cell_node_map</span><span class="p">()),</span>
                     <span class="bp">self</span><span class="o">.</span><span class="n">idx</span><span class="p">(</span><span class="n">op2</span><span class="o">.</span><span class="n">READ</span><span class="p">),</span>
                     <span class="n">iterate</span><span class="o">=</span><span class="n">op2</span><span class="o">.</span><span class="n">ALL</span><span class="p">)</span>
        <span class="c1"># compute global min/max</span>
        <span class="n">r_min</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">output</span><span class="o">.</span><span class="n">dat</span><span class="o">.</span><span class="n">data</span><span class="o">.</span><span class="n">min</span><span class="p">()</span>
        <span class="n">r_max</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">output</span><span class="o">.</span><span class="n">dat</span><span class="o">.</span><span class="n">data</span><span class="o">.</span><span class="n">max</span><span class="p">()</span>
        <span class="n">r_min</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">solver_obj</span><span class="o">.</span><span class="n">comm</span><span class="o">.</span><span class="n">allreduce</span><span class="p">(</span><span class="n">r_min</span><span class="p">,</span> <span class="n">op</span><span class="o">=</span><span class="n">MPI</span><span class="o">.</span><span class="n">MIN</span><span class="p">)</span>
        <span class="n">r_max</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">solver_obj</span><span class="o">.</span><span class="n">comm</span><span class="o">.</span><span class="n">allreduce</span><span class="p">(</span><span class="n">r_max</span><span class="p">,</span> <span class="n">op</span><span class="o">=</span><span class="n">MPI</span><span class="o">.</span><span class="n">MAX</span><span class="p">)</span>
        <span class="n">print_output</span><span class="p">(</span><span class="s1">&#39;HCC: </span><span class="si">{:}</span><span class="s1"> .. </span><span class="si">{:}</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">r_min</span><span class="p">,</span> <span class="n">r_max</span><span class="p">))</span></div></div>


<div class="viewcode-block" id="ExpandFunctionTo3d"><a class="viewcode-back" href="../../thetis.html#thetis.utility.ExpandFunctionTo3d">[docs]</a><span class="k">class</span> <span class="nc">ExpandFunctionTo3d</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Copy a 2D field to 3D</span>

<span class="sd">    Copies a field from 2D mesh to 3D mesh, assigning the same value over the</span>
<span class="sd">    vertical dimension. Horizontal function spaces must be the same.</span>

<span class="sd">    .. code-block:: python</span>

<span class="sd">        U = FunctionSpace(mesh, &#39;DG&#39;, 1)</span>
<span class="sd">        U_2d = FunctionSpace(mesh2d, &#39;DG&#39;, 1)</span>
<span class="sd">        func2d = Function(U_2d)</span>
<span class="sd">        func3d = Function(U)</span>
<span class="sd">        ex = ExpandFunctionTo3d(func2d, func3d)</span>
<span class="sd">        ex.solve()</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">input_2d</span><span class="p">,</span> <span class="n">output_3d</span><span class="p">,</span> <span class="n">elem_height</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        :arg input_2d: 2D source field</span>
<span class="sd">        :type input_2d: :class:`Function`</span>
<span class="sd">        :arg output_3d: 3D target field</span>
<span class="sd">        :type output_3d: :class:`Function`</span>
<span class="sd">        :kwarg elem_height: scalar :class:`Function` in 3D mesh that defines</span>
<span class="sd">            the vertical element size. Needed only in the case of HDiv function</span>
<span class="sd">            spaces.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">input_2d</span> <span class="o">=</span> <span class="n">input_2d</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">output_3d</span> <span class="o">=</span> <span class="n">output_3d</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">fs_2d</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">input_2d</span><span class="o">.</span><span class="n">function_space</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">fs_3d</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">output_3d</span><span class="o">.</span><span class="n">function_space</span><span class="p">()</span>

        <span class="n">family_2d</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">fs_2d</span><span class="o">.</span><span class="n">ufl_element</span><span class="p">()</span><span class="o">.</span><span class="n">family</span><span class="p">()</span>
        <span class="n">ufl_elem</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">fs_3d</span><span class="o">.</span><span class="n">ufl_element</span><span class="p">()</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">ufl_elem</span><span class="p">,</span> <span class="n">ufl</span><span class="o">.</span><span class="n">VectorElement</span><span class="p">):</span>
            <span class="c1"># Unwind vector</span>
            <span class="n">ufl_elem</span> <span class="o">=</span> <span class="n">ufl_elem</span><span class="o">.</span><span class="n">sub_elements</span><span class="p">()[</span><span class="mi">0</span><span class="p">]</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">ufl_elem</span><span class="p">,</span> <span class="n">ufl</span><span class="o">.</span><span class="n">HDivElement</span><span class="p">):</span>
            <span class="c1"># RT case</span>
            <span class="n">ufl_elem</span> <span class="o">=</span> <span class="n">ufl_elem</span><span class="o">.</span><span class="n">_element</span>
        <span class="k">if</span> <span class="n">ufl_elem</span><span class="o">.</span><span class="n">family</span><span class="p">()</span> <span class="o">==</span> <span class="s1">&#39;TensorProductElement&#39;</span><span class="p">:</span>
            <span class="c1"># a normal tensorproduct element</span>
            <span class="n">family_3dh</span> <span class="o">=</span> <span class="n">ufl_elem</span><span class="o">.</span><span class="n">sub_elements</span><span class="p">()[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">family</span><span class="p">()</span>
            <span class="k">if</span> <span class="n">family_2d</span> <span class="o">!=</span> <span class="n">family_3dh</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="s1">&#39;2D and 3D spaces do not match: </span><span class="si">{0:s}</span><span class="s1"> </span><span class="si">{1:s}</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">family_2d</span><span class="p">,</span> <span class="n">family_3dh</span><span class="p">))</span>
        <span class="k">if</span> <span class="n">family_2d</span> <span class="o">==</span> <span class="s1">&#39;Raviart-Thomas&#39;</span> <span class="ow">and</span> <span class="n">elem_height</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="s1">&#39;elem_height must be provided for Raviart-Thomas spaces&#39;</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">do_rt_scaling</span> <span class="o">=</span> <span class="n">family_2d</span> <span class="o">==</span> <span class="s1">&#39;Raviart-Thomas&#39;</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">iter_domain</span> <span class="o">=</span> <span class="n">op2</span><span class="o">.</span><span class="n">ALL</span>

        <span class="c1"># number of nodes in vertical direction</span>
        <span class="n">n_vert_nodes</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">fs_3d</span><span class="o">.</span><span class="n">finat_element</span><span class="o">.</span><span class="n">space_dimension</span><span class="p">()</span> <span class="o">/</span> <span class="bp">self</span><span class="o">.</span><span class="n">fs_2d</span><span class="o">.</span><span class="n">finat_element</span><span class="o">.</span><span class="n">space_dimension</span><span class="p">()</span>

        <span class="n">nodes</span> <span class="o">=</span> <span class="n">get_facet_mask</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">fs_3d</span><span class="p">,</span> <span class="s1">&#39;geometric&#39;</span><span class="p">,</span> <span class="s1">&#39;bottom&#39;</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">idx</span> <span class="o">=</span> <span class="n">op2</span><span class="o">.</span><span class="n">Global</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">nodes</span><span class="p">),</span> <span class="n">nodes</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">int32</span><span class="p">,</span> <span class="n">name</span><span class="o">=</span><span class="s1">&#39;node_idx&#39;</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">kernel</span> <span class="o">=</span> <span class="n">op2</span><span class="o">.</span><span class="n">Kernel</span><span class="p">(</span><span class="s2">&quot;&quot;&quot;</span>
<span class="s2">            void my_kernel(double **func, double **func2d, int *idx) {</span>
<span class="s2">                for ( int d = 0; d &lt; </span><span class="si">%(nodes)d</span><span class="s2">; d++ ) {</span>
<span class="s2">                    for ( int c = 0; c &lt; </span><span class="si">%(func_dim)d</span><span class="s2">; c++ ) {</span>
<span class="s2">                        for ( int e = 0; e &lt; </span><span class="si">%(v_nodes)d</span><span class="s2">; e++ ) {</span>
<span class="s2">                            func[idx[d]+e][c] = func2d[d][c];</span>
<span class="s2">                        }</span>
<span class="s2">                    }</span>
<span class="s2">                }</span>
<span class="s2">            }&quot;&quot;&quot;</span> <span class="o">%</span> <span class="p">{</span><span class="s1">&#39;nodes&#39;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">fs_2d</span><span class="o">.</span><span class="n">finat_element</span><span class="o">.</span><span class="n">space_dimension</span><span class="p">(),</span>
                    <span class="s1">&#39;func_dim&#39;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">input_2d</span><span class="o">.</span><span class="n">function_space</span><span class="p">()</span><span class="o">.</span><span class="n">value_size</span><span class="p">,</span>
                    <span class="s1">&#39;v_nodes&#39;</span><span class="p">:</span> <span class="n">n_vert_nodes</span><span class="p">},</span>
            <span class="s1">&#39;my_kernel&#39;</span><span class="p">)</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">do_rt_scaling</span><span class="p">:</span>
            <span class="n">solver_parameters</span> <span class="o">=</span> <span class="p">{}</span>
            <span class="n">solver_parameters</span><span class="o">.</span><span class="n">setdefault</span><span class="p">(</span><span class="s1">&#39;ksp_atol&#39;</span><span class="p">,</span> <span class="mf">1e-12</span><span class="p">)</span>
            <span class="n">solver_parameters</span><span class="o">.</span><span class="n">setdefault</span><span class="p">(</span><span class="s1">&#39;ksp_rtol&#39;</span><span class="p">,</span> <span class="mf">1e-16</span><span class="p">)</span>
            <span class="n">test</span> <span class="o">=</span> <span class="n">TestFunction</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">fs_3d</span><span class="p">)</span>
            <span class="n">tri</span> <span class="o">=</span> <span class="n">TrialFunction</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">fs_3d</span><span class="p">)</span>
            <span class="n">a</span> <span class="o">=</span> <span class="n">inner</span><span class="p">(</span><span class="n">tri</span><span class="p">,</span> <span class="n">test</span><span class="p">)</span><span class="o">*</span><span class="n">dx</span>
            <span class="n">l</span> <span class="o">=</span> <span class="n">inner</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">output_3d</span><span class="p">,</span> <span class="n">test</span><span class="p">)</span><span class="o">*</span><span class="n">elem_height</span><span class="o">*</span><span class="n">dx</span>
            <span class="n">prob</span> <span class="o">=</span> <span class="n">LinearVariationalProblem</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">l</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">output_3d</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">rt_scale_solver</span> <span class="o">=</span> <span class="n">LinearVariationalSolver</span><span class="p">(</span>
                <span class="n">prob</span><span class="p">,</span> <span class="n">solver_parameters</span><span class="o">=</span><span class="n">solver_parameters</span><span class="p">)</span>

<div class="viewcode-block" id="ExpandFunctionTo3d.solve"><a class="viewcode-back" href="../../thetis.html#thetis.utility.ExpandFunctionTo3d.solve">[docs]</a>    <span class="k">def</span> <span class="nf">solve</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">with</span> <span class="n">timed_stage</span><span class="p">(</span><span class="s1">&#39;copy_2d_to_3d&#39;</span><span class="p">):</span>
            <span class="c1"># execute par loop</span>
            <span class="n">op2</span><span class="o">.</span><span class="n">par_loop</span><span class="p">(</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">kernel</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">fs_3d</span><span class="o">.</span><span class="n">mesh</span><span class="p">()</span><span class="o">.</span><span class="n">cell_set</span><span class="p">,</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">output_3d</span><span class="o">.</span><span class="n">dat</span><span class="p">(</span><span class="n">op2</span><span class="o">.</span><span class="n">WRITE</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">fs_3d</span><span class="o">.</span><span class="n">cell_node_map</span><span class="p">()),</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">input_2d</span><span class="o">.</span><span class="n">dat</span><span class="p">(</span><span class="n">op2</span><span class="o">.</span><span class="n">READ</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">fs_2d</span><span class="o">.</span><span class="n">cell_node_map</span><span class="p">()),</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">idx</span><span class="p">(</span><span class="n">op2</span><span class="o">.</span><span class="n">READ</span><span class="p">),</span>
                <span class="n">iterate</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">iter_domain</span><span class="p">)</span>

            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">do_rt_scaling</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">rt_scale_solver</span><span class="o">.</span><span class="n">solve</span><span class="p">()</span></div></div>


<div class="viewcode-block" id="SubFunctionExtractor"><a class="viewcode-back" href="../../thetis.html#thetis.utility.SubFunctionExtractor">[docs]</a><span class="k">class</span> <span class="nc">SubFunctionExtractor</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Extract a 2D sub-function from a 3D function in an extruded mesh</span>

<span class="sd">    Given 2D and 3D functions,</span>

<span class="sd">    .. code-block:: python</span>

<span class="sd">        U = FunctionSpace(mesh, &#39;DG&#39;, 1)</span>
<span class="sd">        U_2d = FunctionSpace(mesh2d, &#39;DG&#39;, 1)</span>
<span class="sd">        func2d = Function(U_2d)</span>
<span class="sd">        func3d = Function(U)</span>

<span class="sd">    Get surface value:</span>

<span class="sd">    .. code-block:: python</span>

<span class="sd">        ex = SubFunctionExtractor(func3d, func2d,</span>
<span class="sd">            boundary=&#39;top&#39;, elem_facet=&#39;top&#39;)</span>
<span class="sd">        ex.solve()</span>

<span class="sd">    Get bottom value:</span>

<span class="sd">    .. code-block:: python</span>

<span class="sd">        ex = SubFunctionExtractor(func3d, func2d,</span>
<span class="sd">            boundary=&#39;bottom&#39;, elem_facet=&#39;bottom&#39;)</span>
<span class="sd">        ex.solve()</span>

<span class="sd">    Get value at the top of bottom element:</span>

<span class="sd">    .. code-block:: python</span>

<span class="sd">        ex = SubFunctionExtractor(func3d, func2d,</span>
<span class="sd">            boundary=&#39;bottom&#39;, elem_facet=&#39;top&#39;)</span>
<span class="sd">        ex.solve()</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">input_3d</span><span class="p">,</span> <span class="n">output_2d</span><span class="p">,</span>
                 <span class="n">boundary</span><span class="o">=</span><span class="s1">&#39;top&#39;</span><span class="p">,</span> <span class="n">elem_facet</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                 <span class="n">elem_height</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        :arg input_3d: 3D source field</span>
<span class="sd">        :type input_3d: :class:`Function`</span>
<span class="sd">        :arg output_2d: 2D target field</span>
<span class="sd">        :type output_2d: :class:`Function`</span>
<span class="sd">        :kwarg str boundary: &#39;top&#39;|&#39;bottom&#39;</span>
<span class="sd">            Defines whether to extract from the surface or bottom 3D elements</span>
<span class="sd">        :kwarg str elem_facet: &#39;top&#39;|&#39;bottom&#39;|&#39;average&#39;</span>
<span class="sd">            Defines which facet of the 3D element is extracted. The &#39;average&#39;</span>
<span class="sd">            computes mean of the top and bottom facets of the 3D element.</span>
<span class="sd">        :kwarg elem_height: scalar :class:`Function` in 2D mesh that defines</span>
<span class="sd">            the vertical element size. Needed only in the case of HDiv function</span>
<span class="sd">            spaces.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">input_3d</span> <span class="o">=</span> <span class="n">input_3d</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">output_2d</span> <span class="o">=</span> <span class="n">output_2d</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">fs_3d</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">input_3d</span><span class="o">.</span><span class="n">function_space</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">fs_2d</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">output_2d</span><span class="o">.</span><span class="n">function_space</span><span class="p">()</span>

        <span class="k">if</span> <span class="n">elem_facet</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="c1"># extract surface/bottom face by default</span>
            <span class="n">elem_facet</span> <span class="o">=</span> <span class="n">boundary</span>

        <span class="n">family_2d</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">fs_2d</span><span class="o">.</span><span class="n">ufl_element</span><span class="p">()</span><span class="o">.</span><span class="n">family</span><span class="p">()</span>
        <span class="n">elem</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">fs_3d</span><span class="o">.</span><span class="n">ufl_element</span><span class="p">()</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">elem</span><span class="p">,</span> <span class="n">ufl</span><span class="o">.</span><span class="n">VectorElement</span><span class="p">):</span>
            <span class="n">elem</span> <span class="o">=</span> <span class="n">elem</span><span class="o">.</span><span class="n">sub_elements</span><span class="p">()[</span><span class="mi">0</span><span class="p">]</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">elem</span><span class="p">,</span> <span class="n">ufl</span><span class="o">.</span><span class="n">HDivElement</span><span class="p">):</span>
            <span class="n">elem</span> <span class="o">=</span> <span class="n">elem</span><span class="o">.</span><span class="n">_element</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">elem</span><span class="p">,</span> <span class="n">ufl</span><span class="o">.</span><span class="n">TensorProductElement</span><span class="p">):</span>
            <span class="c1"># a normal tensorproduct element</span>
            <span class="n">family_3dh</span> <span class="o">=</span> <span class="n">elem</span><span class="o">.</span><span class="n">sub_elements</span><span class="p">()[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">family</span><span class="p">()</span>
            <span class="k">if</span> <span class="n">family_2d</span> <span class="o">!=</span> <span class="n">family_3dh</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="s1">&#39;2D and 3D spaces do not match: </span><span class="si">{0:s}</span><span class="s1"> </span><span class="si">{1:s}</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">family_2d</span><span class="p">,</span> <span class="n">family_3dh</span><span class="p">))</span>
        <span class="k">if</span> <span class="n">family_2d</span> <span class="o">==</span> <span class="s1">&#39;Raviart-Thomas&#39;</span> <span class="ow">and</span> <span class="n">elem_height</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="s1">&#39;elem_height must be provided for Raviart-Thomas spaces&#39;</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">do_rt_scaling</span> <span class="o">=</span> <span class="n">family_2d</span> <span class="o">==</span> <span class="s1">&#39;Raviart-Thomas&#39;</span>

        <span class="k">assert</span> <span class="n">elem_facet</span> <span class="ow">in</span> <span class="p">[</span><span class="s1">&#39;top&#39;</span><span class="p">,</span> <span class="s1">&#39;bottom&#39;</span><span class="p">,</span> <span class="s1">&#39;average&#39;</span><span class="p">],</span> <span class="s1">&#39;Unsupported elem_facet: </span><span class="si">{:}</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">elem_facet</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">elem_facet</span> <span class="o">==</span> <span class="s1">&#39;average&#39;</span><span class="p">:</span>
            <span class="n">nodes</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">hstack</span><span class="p">((</span><span class="n">get_facet_mask</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">fs_3d</span><span class="p">,</span> <span class="s1">&#39;geometric&#39;</span><span class="p">,</span> <span class="s1">&#39;bottom&#39;</span><span class="p">),</span>
                               <span class="n">get_facet_mask</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">fs_3d</span><span class="p">,</span> <span class="s1">&#39;geometric&#39;</span><span class="p">,</span> <span class="s1">&#39;top&#39;</span><span class="p">)))</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">nodes</span> <span class="o">=</span> <span class="n">get_facet_mask</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">fs_3d</span><span class="p">,</span> <span class="s1">&#39;geometric&#39;</span><span class="p">,</span> <span class="n">elem_facet</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">boundary</span> <span class="o">==</span> <span class="s1">&#39;top&#39;</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">iter_domain</span> <span class="o">=</span> <span class="n">op2</span><span class="o">.</span><span class="n">ON_TOP</span>
        <span class="k">elif</span> <span class="n">boundary</span> <span class="o">==</span> <span class="s1">&#39;bottom&#39;</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">iter_domain</span> <span class="o">=</span> <span class="n">op2</span><span class="o">.</span><span class="n">ON_BOTTOM</span>

        <span class="n">out_nodes</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">fs_2d</span><span class="o">.</span><span class="n">finat_element</span><span class="o">.</span><span class="n">space_dimension</span><span class="p">()</span>

        <span class="k">if</span> <span class="n">elem_facet</span> <span class="o">==</span> <span class="s1">&#39;average&#39;</span><span class="p">:</span>
            <span class="k">assert</span> <span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">nodes</span><span class="p">)</span> <span class="o">==</span> <span class="mi">2</span><span class="o">*</span><span class="n">out_nodes</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">assert</span> <span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">nodes</span><span class="p">)</span> <span class="o">==</span> <span class="n">out_nodes</span><span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">idx</span> <span class="o">=</span> <span class="n">op2</span><span class="o">.</span><span class="n">Global</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">nodes</span><span class="p">),</span> <span class="n">nodes</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">int32</span><span class="p">,</span> <span class="n">name</span><span class="o">=</span><span class="s1">&#39;node_idx&#39;</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">elem_facet</span> <span class="o">==</span> <span class="s1">&#39;average&#39;</span><span class="p">:</span>
            <span class="c1"># compute average of top and bottom elem nodes</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">kernel</span> <span class="o">=</span> <span class="n">op2</span><span class="o">.</span><span class="n">Kernel</span><span class="p">(</span><span class="s2">&quot;&quot;&quot;</span>
<span class="s2">                void my_kernel(double **func, double **func3d, int *idx) {</span>
<span class="s2">                    int nnodes = </span><span class="si">%(nodes)d</span><span class="s2">;</span>
<span class="s2">                    for ( int d = 0; d &lt; nnodes; d++ ) {</span>
<span class="s2">                        for ( int c = 0; c &lt; </span><span class="si">%(func_dim)d</span><span class="s2">; c++ ) {</span>
<span class="s2">                            func[d][c] = 0.5*(func3d[idx[d]][c] +</span>
<span class="s2">                                              func3d[idx[d + nnodes]][c]);</span>
<span class="s2">                        }</span>
<span class="s2">                    }</span>
<span class="s2">                }&quot;&quot;&quot;</span> <span class="o">%</span> <span class="p">{</span><span class="s1">&#39;nodes&#39;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">output_2d</span><span class="o">.</span><span class="n">cell_node_map</span><span class="p">()</span><span class="o">.</span><span class="n">arity</span><span class="p">,</span>
                        <span class="s1">&#39;func_dim&#39;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">output_2d</span><span class="o">.</span><span class="n">function_space</span><span class="p">()</span><span class="o">.</span><span class="n">value_size</span><span class="p">},</span>
                <span class="s1">&#39;my_kernel&#39;</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">kernel</span> <span class="o">=</span> <span class="n">op2</span><span class="o">.</span><span class="n">Kernel</span><span class="p">(</span><span class="s2">&quot;&quot;&quot;</span>
<span class="s2">                void my_kernel(double **func, double **func3d, int *idx) {</span>
<span class="s2">                    for ( int d = 0; d &lt; </span><span class="si">%(nodes)d</span><span class="s2">; d++ ) {</span>
<span class="s2">                        for ( int c = 0; c &lt; </span><span class="si">%(func_dim)d</span><span class="s2">; c++ ) {</span>
<span class="s2">                            func[d][c] = func3d[idx[d]][c];</span>
<span class="s2">                        }</span>
<span class="s2">                    }</span>
<span class="s2">                }&quot;&quot;&quot;</span> <span class="o">%</span> <span class="p">{</span><span class="s1">&#39;nodes&#39;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">output_2d</span><span class="o">.</span><span class="n">cell_node_map</span><span class="p">()</span><span class="o">.</span><span class="n">arity</span><span class="p">,</span>
                        <span class="s1">&#39;func_dim&#39;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">output_2d</span><span class="o">.</span><span class="n">function_space</span><span class="p">()</span><span class="o">.</span><span class="n">value_size</span><span class="p">},</span>
                <span class="s1">&#39;my_kernel&#39;</span><span class="p">)</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">do_rt_scaling</span><span class="p">:</span>
            <span class="n">solver_parameters</span> <span class="o">=</span> <span class="p">{}</span>
            <span class="n">solver_parameters</span><span class="o">.</span><span class="n">setdefault</span><span class="p">(</span><span class="s1">&#39;ksp_atol&#39;</span><span class="p">,</span> <span class="mf">1e-12</span><span class="p">)</span>
            <span class="n">solver_parameters</span><span class="o">.</span><span class="n">setdefault</span><span class="p">(</span><span class="s1">&#39;ksp_rtol&#39;</span><span class="p">,</span> <span class="mf">1e-16</span><span class="p">)</span>
            <span class="n">test</span> <span class="o">=</span> <span class="n">TestFunction</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">fs_2d</span><span class="p">)</span>
            <span class="n">tri</span> <span class="o">=</span> <span class="n">TrialFunction</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">fs_2d</span><span class="p">)</span>
            <span class="n">a</span> <span class="o">=</span> <span class="n">inner</span><span class="p">(</span><span class="n">tri</span><span class="p">,</span> <span class="n">test</span><span class="p">)</span><span class="o">*</span><span class="n">dx</span>
            <span class="n">l</span> <span class="o">=</span> <span class="n">inner</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">output_2d</span><span class="p">,</span> <span class="n">test</span><span class="p">)</span><span class="o">/</span><span class="n">elem_height</span><span class="o">*</span><span class="n">dx</span>
            <span class="n">prob</span> <span class="o">=</span> <span class="n">LinearVariationalProblem</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">l</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">output_2d</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">rt_scale_solver</span> <span class="o">=</span> <span class="n">LinearVariationalSolver</span><span class="p">(</span>
                <span class="n">prob</span><span class="p">,</span> <span class="n">solver_parameters</span><span class="o">=</span><span class="n">solver_parameters</span><span class="p">)</span>

<div class="viewcode-block" id="SubFunctionExtractor.solve"><a class="viewcode-back" href="../../thetis.html#thetis.utility.SubFunctionExtractor.solve">[docs]</a>    <span class="k">def</span> <span class="nf">solve</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">with</span> <span class="n">timed_stage</span><span class="p">(</span><span class="s1">&#39;copy_3d_to_2d&#39;</span><span class="p">):</span>
            <span class="c1"># execute par loop</span>
            <span class="n">op2</span><span class="o">.</span><span class="n">par_loop</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">kernel</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">fs_3d</span><span class="o">.</span><span class="n">mesh</span><span class="p">()</span><span class="o">.</span><span class="n">cell_set</span><span class="p">,</span>
                         <span class="bp">self</span><span class="o">.</span><span class="n">output_2d</span><span class="o">.</span><span class="n">dat</span><span class="p">(</span><span class="n">op2</span><span class="o">.</span><span class="n">WRITE</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">fs_2d</span><span class="o">.</span><span class="n">cell_node_map</span><span class="p">()),</span>
                         <span class="bp">self</span><span class="o">.</span><span class="n">input_3d</span><span class="o">.</span><span class="n">dat</span><span class="p">(</span><span class="n">op2</span><span class="o">.</span><span class="n">READ</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">fs_3d</span><span class="o">.</span><span class="n">cell_node_map</span><span class="p">()),</span>
                         <span class="bp">self</span><span class="o">.</span><span class="n">idx</span><span class="p">(</span><span class="n">op2</span><span class="o">.</span><span class="n">READ</span><span class="p">),</span>
                         <span class="n">iterate</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">iter_domain</span><span class="p">)</span>

            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">do_rt_scaling</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">rt_scale_solver</span><span class="o">.</span><span class="n">solve</span><span class="p">()</span></div></div>


<div class="viewcode-block" id="compute_elem_height"><a class="viewcode-back" href="../../thetis.html#thetis.utility.compute_elem_height">[docs]</a><span class="k">def</span> <span class="nf">compute_elem_height</span><span class="p">(</span><span class="n">zcoord</span><span class="p">,</span> <span class="n">output</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Computes the element height on an extruded mesh.</span>

<span class="sd">    :arg zcoord: field that contains the z coordinates of the mesh</span>
<span class="sd">    :type zcoord: :class:`Function`</span>
<span class="sd">    :arg output: field where element height is stored</span>
<span class="sd">    :type output: :class:`Function`</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">fs_in</span> <span class="o">=</span> <span class="n">zcoord</span><span class="o">.</span><span class="n">function_space</span><span class="p">()</span>
    <span class="n">fs_out</span> <span class="o">=</span> <span class="n">output</span><span class="o">.</span><span class="n">function_space</span><span class="p">()</span>

    <span class="n">iterate</span> <span class="o">=</span> <span class="n">op2</span><span class="o">.</span><span class="n">ALL</span>

    <span class="c1"># NOTE height maybe &lt;0 if mesh was extruded like that</span>
    <span class="n">kernel</span> <span class="o">=</span> <span class="n">op2</span><span class="o">.</span><span class="n">Kernel</span><span class="p">(</span><span class="s2">&quot;&quot;&quot;</span>
<span class="s2">        void my_kernel(double **func, double **zcoord) {</span>
<span class="s2">            for ( int d = 0; d &lt; </span><span class="si">%(nodes)d</span><span class="s2">/2; d++ ) {</span>
<span class="s2">                for ( int c = 0; c &lt; </span><span class="si">%(func_dim)d</span><span class="s2">; c++ ) {</span>
<span class="s2">                    double dz = fabs(zcoord[2*d+1][c] - zcoord[2*d][c]);</span>
<span class="s2">                    func[2*d][c] = dz;</span>
<span class="s2">                    func[2*d+1][c] = dz;</span>
<span class="s2">                }</span>
<span class="s2">            }</span>
<span class="s2">        }&quot;&quot;&quot;</span> <span class="o">%</span> <span class="p">{</span><span class="s1">&#39;nodes&#39;</span><span class="p">:</span> <span class="n">zcoord</span><span class="o">.</span><span class="n">cell_node_map</span><span class="p">()</span><span class="o">.</span><span class="n">arity</span><span class="p">,</span>
                <span class="s1">&#39;func_dim&#39;</span><span class="p">:</span> <span class="n">zcoord</span><span class="o">.</span><span class="n">function_space</span><span class="p">()</span><span class="o">.</span><span class="n">value_size</span><span class="p">},</span>
        <span class="s1">&#39;my_kernel&#39;</span><span class="p">)</span>
    <span class="n">op2</span><span class="o">.</span><span class="n">par_loop</span><span class="p">(</span>
        <span class="n">kernel</span><span class="p">,</span> <span class="n">fs_out</span><span class="o">.</span><span class="n">mesh</span><span class="p">()</span><span class="o">.</span><span class="n">cell_set</span><span class="p">,</span>
        <span class="n">output</span><span class="o">.</span><span class="n">dat</span><span class="p">(</span><span class="n">op2</span><span class="o">.</span><span class="n">WRITE</span><span class="p">,</span> <span class="n">fs_out</span><span class="o">.</span><span class="n">cell_node_map</span><span class="p">()),</span>
        <span class="n">zcoord</span><span class="o">.</span><span class="n">dat</span><span class="p">(</span><span class="n">op2</span><span class="o">.</span><span class="n">READ</span><span class="p">,</span> <span class="n">fs_in</span><span class="o">.</span><span class="n">cell_node_map</span><span class="p">()),</span>
        <span class="n">iterate</span><span class="o">=</span><span class="n">iterate</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">output</span></div>


<div class="viewcode-block" id="compute_bottom_drag"><a class="viewcode-back" href="../../thetis.html#thetis.utility.compute_bottom_drag">[docs]</a><span class="k">def</span> <span class="nf">compute_bottom_drag</span><span class="p">(</span><span class="n">h_b</span><span class="p">,</span> <span class="n">drag</span><span class="p">):</span>
    <span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Computes bottom drag coefficient (Cd) from the law-of-the wall</span>

<span class="sd">    .. math::</span>
<span class="sd">        C_D = \left( \frac{\kappa}{\ln (h_b + z_0)/z_0} \right)^2</span>

<span class="sd">    :arg h_b: the height above bed where the bottom velocity is evaluated in</span>
<span class="sd">        the law-of-the-wall fit</span>
<span class="sd">    :type h_b: :class:`Function`</span>
<span class="sd">    :arg drag: field where C_D is stored</span>
<span class="sd">    :type drag: :class:`Function`</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1"># FIXME z0 should be a field, i.e. an argument to this function</span>
    <span class="n">von_karman</span> <span class="o">=</span> <span class="n">physical_constants</span><span class="p">[</span><span class="s1">&#39;von_karman&#39;</span><span class="p">]</span>
    <span class="n">z0_friction</span> <span class="o">=</span> <span class="n">physical_constants</span><span class="p">[</span><span class="s1">&#39;z0_friction&#39;</span><span class="p">]</span>
    <span class="n">drag</span><span class="o">.</span><span class="n">assign</span><span class="p">((</span><span class="n">von_karman</span> <span class="o">/</span> <span class="n">ln</span><span class="p">((</span><span class="n">h_b</span> <span class="o">+</span> <span class="n">z0_friction</span><span class="p">)</span><span class="o">/</span><span class="n">z0_friction</span><span class="p">))</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">drag</span></div>


<div class="viewcode-block" id="compute_bottom_friction"><a class="viewcode-back" href="../../thetis.html#thetis.utility.compute_bottom_friction">[docs]</a><span class="k">def</span> <span class="nf">compute_bottom_friction</span><span class="p">(</span><span class="n">solver</span><span class="p">,</span> <span class="n">uv_3d</span><span class="p">,</span> <span class="n">uv_bottom_2d</span><span class="p">,</span>
                            <span class="n">z_bottom_2d</span><span class="p">,</span> <span class="n">bathymetry_2d</span><span class="p">,</span>
                            <span class="n">bottom_drag_2d</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Updates bottom friction related fields for the 3D model</span>

<span class="sd">    :arg solver: :class:`FlowSolver` object</span>
<span class="sd">    :arg uv_3d: horizontal velocity</span>
<span class="sd">    :type uv_3d: 3D vector :class:`Function`</span>
<span class="sd">    :arg uv_bottom_2d: 2D bottom velocity field</span>
<span class="sd">    :type uv_bottom_2d: 2D vector :class:`Function`</span>
<span class="sd">    :arg z_bottom_2d: Bottom element z coordinate</span>
<span class="sd">    :type z_bottom_2d: 2D scalar :class:`Function`</span>
<span class="sd">    :arg bathymetry_2d: Bathymetry field</span>
<span class="sd">    :type bathymetry_2d: 2D scalar :class:`Function`</span>
<span class="sd">    :arg bottom_drag_2d: Bottom grad field</span>
<span class="sd">    :type bottom_drag_2d: 2D scalar :class:`Function`</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1"># TODO all input fields could be just fetched from solver.fields ...</span>
    <span class="c1"># compute velocity at middle of bottom element</span>
    <span class="n">solver</span><span class="o">.</span><span class="n">extract_uv_bottom</span><span class="o">.</span><span class="n">solve</span><span class="p">()</span>
    <span class="n">solver</span><span class="o">.</span><span class="n">extract_z_bottom</span><span class="o">.</span><span class="n">solve</span><span class="p">()</span>
    <span class="n">z_bottom_2d</span><span class="o">.</span><span class="n">assign</span><span class="p">((</span><span class="n">z_bottom_2d</span> <span class="o">+</span> <span class="n">bathymetry_2d</span><span class="p">))</span>
    <span class="n">compute_bottom_drag</span><span class="p">(</span><span class="n">z_bottom_2d</span><span class="p">,</span> <span class="n">bottom_drag_2d</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">solver</span><span class="o">.</span><span class="n">options</span><span class="o">.</span><span class="n">use_parabolic_viscosity</span><span class="p">:</span>
        <span class="n">solver</span><span class="o">.</span><span class="n">copy_uv_bottom_to_3d</span><span class="o">.</span><span class="n">solve</span><span class="p">()</span>
        <span class="n">solver</span><span class="o">.</span><span class="n">copy_bottom_drag_to_3d</span><span class="o">.</span><span class="n">solve</span><span class="p">()</span></div>


<div class="viewcode-block" id="get_horizontal_elem_size_2d"><a class="viewcode-back" href="../../thetis.html#thetis.utility.get_horizontal_elem_size_2d">[docs]</a><span class="k">def</span> <span class="nf">get_horizontal_elem_size_2d</span><span class="p">(</span><span class="n">sol2d</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Computes horizontal element size from the 2D mesh</span>

<span class="sd">    :arg sol2d: 2D :class:`Function` where result is stored</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">p1_2d</span> <span class="o">=</span> <span class="n">sol2d</span><span class="o">.</span><span class="n">function_space</span><span class="p">()</span>
    <span class="n">mesh</span> <span class="o">=</span> <span class="n">p1_2d</span><span class="o">.</span><span class="n">mesh</span><span class="p">()</span>
    <span class="n">test</span> <span class="o">=</span> <span class="n">TestFunction</span><span class="p">(</span><span class="n">p1_2d</span><span class="p">)</span>
    <span class="n">tri</span> <span class="o">=</span> <span class="n">TrialFunction</span><span class="p">(</span><span class="n">p1_2d</span><span class="p">)</span>
    <span class="n">a</span> <span class="o">=</span> <span class="n">inner</span><span class="p">(</span><span class="n">test</span><span class="p">,</span> <span class="n">tri</span><span class="p">)</span> <span class="o">*</span> <span class="n">dx</span>
    <span class="n">l</span> <span class="o">=</span> <span class="n">inner</span><span class="p">(</span><span class="n">test</span><span class="p">,</span> <span class="n">sqrt</span><span class="p">(</span><span class="n">CellVolume</span><span class="p">(</span><span class="n">mesh</span><span class="p">)))</span> <span class="o">*</span> <span class="n">dx</span>
    <span class="n">solve</span><span class="p">(</span><span class="n">a</span> <span class="o">==</span> <span class="n">l</span><span class="p">,</span> <span class="n">sol2d</span><span class="p">)</span></div>


<div class="viewcode-block" id="get_horizontal_elem_size_3d"><a class="viewcode-back" href="../../thetis.html#thetis.utility.get_horizontal_elem_size_3d">[docs]</a><span class="k">def</span> <span class="nf">get_horizontal_elem_size_3d</span><span class="p">(</span><span class="n">sol2d</span><span class="p">,</span> <span class="n">sol3d</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Computes horizontal element size from the 2D mesh, then copies it on a 3D</span>
<span class="sd">    field</span>

<span class="sd">    :arg sol2d: 2D :class:`Function` for the element size field</span>
<span class="sd">    :arg sol3d: 3D :class:`Function` for the element size field</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">get_horizontal_elem_size_2d</span><span class="p">(</span><span class="n">sol2d</span><span class="p">)</span>
    <span class="n">ExpandFunctionTo3d</span><span class="p">(</span><span class="n">sol2d</span><span class="p">,</span> <span class="n">sol3d</span><span class="p">)</span><span class="o">.</span><span class="n">solve</span><span class="p">()</span></div>


<div class="viewcode-block" id="ALEMeshUpdater"><a class="viewcode-back" href="../../thetis.html#thetis.utility.ALEMeshUpdater">[docs]</a><span class="k">class</span> <span class="nc">ALEMeshUpdater</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Class that handles vertically moving ALE mesh</span>

<span class="sd">    Mesh geometry is updated to match the elevation field</span>
<span class="sd">    (``solver.fields.elev_2d``). First the discontinuous elevation field is</span>
<span class="sd">    projected to continuous space, and this field is used to update the mesh</span>
<span class="sd">    coordinates.</span>

<span class="sd">    This class stores the reference coordinate field and keeps track of the</span>
<span class="sd">    updated mesh coordinates. It also provides a method for computing the mesh</span>
<span class="sd">    velocity from two adjacent elevation fields.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">solver</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        :arg solver: :class:`FlowSolver` object</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">solver</span> <span class="o">=</span> <span class="n">solver</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">fields</span> <span class="o">=</span> <span class="n">solver</span><span class="o">.</span><span class="n">fields</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">solver</span><span class="o">.</span><span class="n">options</span><span class="o">.</span><span class="n">use_ale_moving_mesh</span><span class="p">:</span>
            <span class="c1"># continous elevation</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">elev_cg_2d</span> <span class="o">=</span> <span class="n">Function</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">solver</span><span class="o">.</span><span class="n">function_spaces</span><span class="o">.</span><span class="n">P1_2d</span><span class="p">,</span>
                                       <span class="n">name</span><span class="o">=</span><span class="s1">&#39;elev cg 2d&#39;</span><span class="p">)</span>
            <span class="c1"># elevation in coordinate space</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">proj_elev_to_cg_2d</span> <span class="o">=</span> <span class="n">Projector</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">fields</span><span class="o">.</span><span class="n">elev_2d</span><span class="p">,</span>
                                                <span class="bp">self</span><span class="o">.</span><span class="n">elev_cg_2d</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">proj_elev_cg_to_coords_2d</span> <span class="o">=</span> <span class="n">Projector</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">elev_cg_2d</span><span class="p">,</span>
                                                       <span class="bp">self</span><span class="o">.</span><span class="n">fields</span><span class="o">.</span><span class="n">elev_cg_2d</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">cp_elev_2d_to_3d</span> <span class="o">=</span> <span class="n">ExpandFunctionTo3d</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">fields</span><span class="o">.</span><span class="n">elev_cg_2d</span><span class="p">,</span>
                                                       <span class="bp">self</span><span class="o">.</span><span class="n">fields</span><span class="o">.</span><span class="n">elev_cg_3d</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">cp_w_mesh_surf_2d_to_3d</span> <span class="o">=</span> <span class="n">ExpandFunctionTo3d</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">fields</span><span class="o">.</span><span class="n">w_mesh_surf_2d</span><span class="p">,</span>
                                                              <span class="bp">self</span><span class="o">.</span><span class="n">fields</span><span class="o">.</span><span class="n">w_mesh_surf_3d</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">cp_v_elem_size_to_2d</span> <span class="o">=</span> <span class="n">SubFunctionExtractor</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">fields</span><span class="o">.</span><span class="n">v_elem_size_3d</span><span class="p">,</span>
                                                         <span class="bp">self</span><span class="o">.</span><span class="n">fields</span><span class="o">.</span><span class="n">v_elem_size_2d</span><span class="p">,</span>
                                                         <span class="n">boundary</span><span class="o">=</span><span class="s1">&#39;top&#39;</span><span class="p">,</span> <span class="n">elem_facet</span><span class="o">=</span><span class="s1">&#39;top&#39;</span><span class="p">)</span>

<div class="viewcode-block" id="ALEMeshUpdater.initialize"><a class="viewcode-back" href="../../thetis.html#thetis.utility.ALEMeshUpdater.initialize">[docs]</a>    <span class="k">def</span> <span class="nf">initialize</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Set values for initial mesh (elevation at rest)&quot;&quot;&quot;</span>
        <span class="n">get_zcoord_from_mesh</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">fields</span><span class="o">.</span><span class="n">z_coord_ref_3d</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">fields</span><span class="o">.</span><span class="n">z_coord_3d</span><span class="o">.</span><span class="n">assign</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">fields</span><span class="o">.</span><span class="n">z_coord_ref_3d</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">update_elem_height</span><span class="p">()</span></div>

<div class="viewcode-block" id="ALEMeshUpdater.update_elem_height"><a class="viewcode-back" href="../../thetis.html#thetis.utility.ALEMeshUpdater.update_elem_height">[docs]</a>    <span class="k">def</span> <span class="nf">update_elem_height</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Updates vertical element size fields&quot;&quot;&quot;</span>
        <span class="n">compute_elem_height</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">fields</span><span class="o">.</span><span class="n">z_coord_3d</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">fields</span><span class="o">.</span><span class="n">v_elem_size_3d</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">cp_v_elem_size_to_2d</span><span class="o">.</span><span class="n">solve</span><span class="p">()</span></div>

<div class="viewcode-block" id="ALEMeshUpdater.compute_mesh_velocity_begin"><a class="viewcode-back" href="../../thetis.html#thetis.utility.ALEMeshUpdater.compute_mesh_velocity_begin">[docs]</a>    <span class="k">def</span> <span class="nf">compute_mesh_velocity_begin</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Stores the current 2D elevation state as the &quot;old&quot; field&quot;&quot;&quot;</span>
        <span class="k">assert</span> <span class="bp">self</span><span class="o">.</span><span class="n">solver</span><span class="o">.</span><span class="n">options</span><span class="o">.</span><span class="n">use_ale_moving_mesh</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">proj_elev_to_cg_2d</span><span class="o">.</span><span class="n">project</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">proj_elev_cg_to_coords_2d</span><span class="o">.</span><span class="n">project</span><span class="p">()</span></div>

<div class="viewcode-block" id="ALEMeshUpdater.compute_mesh_velocity_finalize"><a class="viewcode-back" href="../../thetis.html#thetis.utility.ALEMeshUpdater.compute_mesh_velocity_finalize">[docs]</a>    <span class="k">def</span> <span class="nf">compute_mesh_velocity_finalize</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">c</span><span class="o">=</span><span class="mf">1.0</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Computes mesh velocity from the elevation difference</span>

<span class="sd">        Stores the current 2D elevation state as the &quot;new&quot; field,</span>
<span class="sd">        and computes w_mesh using the given time step factor ``c``.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># compute w_mesh_surf = (elev_new - elev_old)/dt/c</span>
        <span class="k">assert</span> <span class="bp">self</span><span class="o">.</span><span class="n">solver</span><span class="o">.</span><span class="n">options</span><span class="o">.</span><span class="n">use_ale_moving_mesh</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">fields</span><span class="o">.</span><span class="n">w_mesh_surf_2d</span><span class="o">.</span><span class="n">assign</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">fields</span><span class="o">.</span><span class="n">elev_cg_2d</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">proj_elev_to_cg_2d</span><span class="o">.</span><span class="n">project</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">proj_elev_cg_to_coords_2d</span><span class="o">.</span><span class="n">project</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">fields</span><span class="o">.</span><span class="n">w_mesh_surf_2d</span> <span class="o">+=</span> <span class="o">-</span><span class="bp">self</span><span class="o">.</span><span class="n">fields</span><span class="o">.</span><span class="n">elev_cg_2d</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">fields</span><span class="o">.</span><span class="n">w_mesh_surf_2d</span> <span class="o">*=</span> <span class="o">-</span><span class="mf">1.0</span><span class="o">/</span><span class="bp">self</span><span class="o">.</span><span class="n">solver</span><span class="o">.</span><span class="n">dt</span><span class="o">/</span><span class="n">c</span>
        <span class="c1"># use that to compute w_mesh in whole domain</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">cp_w_mesh_surf_2d_to_3d</span><span class="o">.</span><span class="n">solve</span><span class="p">()</span>
        <span class="c1"># solve w_mesh at nodes</span>
        <span class="n">w_mesh_surf</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">fields</span><span class="o">.</span><span class="n">w_mesh_surf_3d</span><span class="o">.</span><span class="n">dat</span><span class="o">.</span><span class="n">data</span><span class="p">[:]</span>
        <span class="n">z_ref</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">fields</span><span class="o">.</span><span class="n">z_coord_ref_3d</span><span class="o">.</span><span class="n">dat</span><span class="o">.</span><span class="n">data</span><span class="p">[:]</span>
        <span class="n">h</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">fields</span><span class="o">.</span><span class="n">bathymetry_3d</span><span class="o">.</span><span class="n">dat</span><span class="o">.</span><span class="n">data</span><span class="p">[:]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">fields</span><span class="o">.</span><span class="n">w_mesh_3d</span><span class="o">.</span><span class="n">dat</span><span class="o">.</span><span class="n">data</span><span class="p">[:]</span> <span class="o">=</span> <span class="n">w_mesh_surf</span> <span class="o">*</span> <span class="p">(</span><span class="n">z_ref</span> <span class="o">+</span> <span class="n">h</span><span class="p">)</span><span class="o">/</span><span class="n">h</span></div>

<div class="viewcode-block" id="ALEMeshUpdater.update_mesh_coordinates"><a class="viewcode-back" href="../../thetis.html#thetis.utility.ALEMeshUpdater.update_mesh_coordinates">[docs]</a>    <span class="k">def</span> <span class="nf">update_mesh_coordinates</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Updates 3D mesh coordinates to match current elev_2d field</span>

<span class="sd">        elev_2d is first projected to continous space</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">assert</span> <span class="bp">self</span><span class="o">.</span><span class="n">solver</span><span class="o">.</span><span class="n">options</span><span class="o">.</span><span class="n">use_ale_moving_mesh</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">proj_elev_to_cg_2d</span><span class="o">.</span><span class="n">project</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">proj_elev_cg_to_coords_2d</span><span class="o">.</span><span class="n">project</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">cp_elev_2d_to_3d</span><span class="o">.</span><span class="n">solve</span><span class="p">()</span>

        <span class="n">eta</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">fields</span><span class="o">.</span><span class="n">elev_cg_3d</span><span class="o">.</span><span class="n">dat</span><span class="o">.</span><span class="n">data</span><span class="p">[:]</span>
        <span class="n">z_ref</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">fields</span><span class="o">.</span><span class="n">z_coord_ref_3d</span><span class="o">.</span><span class="n">dat</span><span class="o">.</span><span class="n">data</span><span class="p">[:]</span>
        <span class="n">bath</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">fields</span><span class="o">.</span><span class="n">bathymetry_3d</span><span class="o">.</span><span class="n">dat</span><span class="o">.</span><span class="n">data</span><span class="p">[:]</span>
        <span class="n">new_z</span> <span class="o">=</span> <span class="n">eta</span><span class="o">*</span><span class="p">(</span><span class="n">z_ref</span> <span class="o">+</span> <span class="n">bath</span><span class="p">)</span><span class="o">/</span><span class="n">bath</span> <span class="o">+</span> <span class="n">z_ref</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">solver</span><span class="o">.</span><span class="n">mesh</span><span class="o">.</span><span class="n">coordinates</span><span class="o">.</span><span class="n">dat</span><span class="o">.</span><span class="n">data</span><span class="p">[:,</span> <span class="mi">2</span><span class="p">]</span> <span class="o">=</span> <span class="n">new_z</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">fields</span><span class="o">.</span><span class="n">z_coord_3d</span><span class="o">.</span><span class="n">dat</span><span class="o">.</span><span class="n">data</span><span class="p">[:]</span> <span class="o">=</span> <span class="n">new_z</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">update_elem_height</span><span class="p">()</span></div></div>


<div class="viewcode-block" id="ParabolicViscosity"><a class="viewcode-back" href="../../thetis.html#thetis.utility.ParabolicViscosity">[docs]</a><span class="k">class</span> <span class="nc">ParabolicViscosity</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>
    <span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Computes parabolic eddy viscosity profile assuming log layer flow</span>

<span class="sd">    .. math::</span>
<span class="sd">        \nu = \kappa u_{bf}  \frac{(-z)(h + z_0 + z)}{h + z_0}</span>

<span class="sd">    with</span>

<span class="sd">    .. math::</span>
<span class="sd">        u_{bf} = \sqrt{C_D} |\mathbf{u}_b|</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">uv_bottom</span><span class="p">,</span> <span class="n">bottom_drag</span><span class="p">,</span> <span class="n">bathymetry</span><span class="p">,</span> <span class="n">nu</span><span class="p">,</span>
                 <span class="n">solver_parameters</span><span class="o">=</span><span class="p">{}):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        :arg uv_bottom: bottom velocity</span>
<span class="sd">        :type uv_bottom: 3D :class:`Function`</span>
<span class="sd">        :arg bottom_drag: bottom drag field</span>
<span class="sd">        :type bottom_drag: 3D :class:`Function`</span>
<span class="sd">        :arg bathymetry: bathymetry field</span>
<span class="sd">        :type bathymetry: 3D :class:`Function`</span>
<span class="sd">        :arg nu: eddy viscosity field</span>
<span class="sd">        :type nu: 3D :class:`Function`</span>
<span class="sd">        :kwarg dict solver_parameters: PETSc solver options</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">solver_parameters</span><span class="o">.</span><span class="n">setdefault</span><span class="p">(</span><span class="s1">&#39;ksp_atol&#39;</span><span class="p">,</span> <span class="mf">1e-12</span><span class="p">)</span>
        <span class="n">solver_parameters</span><span class="o">.</span><span class="n">setdefault</span><span class="p">(</span><span class="s1">&#39;ksp_rtol&#39;</span><span class="p">,</span> <span class="mf">1e-16</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">min_val</span> <span class="o">=</span> <span class="mf">1e-10</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">solution</span> <span class="o">=</span> <span class="n">nu</span>

        <span class="n">kappa</span> <span class="o">=</span> <span class="n">physical_constants</span><span class="p">[</span><span class="s1">&#39;von_karman&#39;</span><span class="p">]</span>
        <span class="n">z0</span> <span class="o">=</span> <span class="n">physical_constants</span><span class="p">[</span><span class="s1">&#39;z0_friction&#39;</span><span class="p">]</span>
        <span class="n">fs</span> <span class="o">=</span> <span class="n">nu</span><span class="o">.</span><span class="n">function_space</span><span class="p">()</span>
        <span class="n">x</span> <span class="o">=</span> <span class="n">fs</span><span class="o">.</span><span class="n">mesh</span><span class="p">()</span><span class="o">.</span><span class="n">coordinates</span>
        <span class="n">test</span> <span class="o">=</span> <span class="n">TestFunction</span><span class="p">(</span><span class="n">fs</span><span class="p">)</span>
        <span class="n">tri</span> <span class="o">=</span> <span class="n">TrialFunction</span><span class="p">(</span><span class="n">fs</span><span class="p">)</span>
        <span class="n">a</span> <span class="o">=</span> <span class="n">tri</span><span class="o">*</span><span class="n">test</span><span class="o">*</span><span class="n">dx</span>
        <span class="n">uv_mag</span> <span class="o">=</span> <span class="n">sqrt</span><span class="p">(</span><span class="n">uv_bottom</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">**</span><span class="mi">2</span> <span class="o">+</span> <span class="n">uv_bottom</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span>
        <span class="n">parabola</span> <span class="o">=</span> <span class="o">-</span><span class="n">x</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span><span class="o">*</span><span class="p">(</span><span class="n">bathymetry</span> <span class="o">+</span> <span class="n">z0</span> <span class="o">+</span> <span class="n">x</span><span class="p">[</span><span class="mi">2</span><span class="p">])</span><span class="o">/</span><span class="p">(</span><span class="n">bathymetry</span> <span class="o">+</span> <span class="n">z0</span><span class="p">)</span>
        <span class="n">l</span> <span class="o">=</span> <span class="n">kappa</span><span class="o">*</span><span class="n">sqrt</span><span class="p">(</span><span class="n">bottom_drag</span><span class="p">)</span><span class="o">*</span><span class="n">uv_mag</span><span class="o">*</span><span class="n">parabola</span><span class="o">*</span><span class="n">test</span><span class="o">*</span><span class="n">dx</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">prob</span> <span class="o">=</span> <span class="n">LinearVariationalProblem</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">l</span><span class="p">,</span> <span class="n">nu</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">solver</span> <span class="o">=</span> <span class="n">LinearVariationalSolver</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">prob</span><span class="p">,</span> <span class="n">solver_parameters</span><span class="o">=</span><span class="n">solver_parameters</span><span class="p">)</span>

<div class="viewcode-block" id="ParabolicViscosity.solve"><a class="viewcode-back" href="../../thetis.html#thetis.utility.ParabolicViscosity.solve">[docs]</a>    <span class="k">def</span> <span class="nf">solve</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Computes viscosity and stores it in nu field</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">solver</span><span class="o">.</span><span class="n">solve</span><span class="p">()</span>
        <span class="c1"># remove negative values</span>
        <span class="n">ix</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">solution</span><span class="o">.</span><span class="n">dat</span><span class="o">.</span><span class="n">data</span><span class="p">[:]</span> <span class="o">&lt;</span> <span class="bp">self</span><span class="o">.</span><span class="n">min_val</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">solution</span><span class="o">.</span><span class="n">dat</span><span class="o">.</span><span class="n">data</span><span class="p">[</span><span class="n">ix</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">min_val</span></div></div>


<div class="viewcode-block" id="beta_plane_coriolis_params"><a class="viewcode-back" href="../../thetis.html#thetis.utility.beta_plane_coriolis_params">[docs]</a><span class="k">def</span> <span class="nf">beta_plane_coriolis_params</span><span class="p">(</span><span class="n">latitude</span><span class="p">):</span>
    <span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Computes beta plane parameters :math:`f_0,\beta` based on latitude</span>

<span class="sd">    :arg float latitude: latitude in degrees</span>
<span class="sd">    :return: f_0, beta</span>
<span class="sd">    :rtype: float</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">omega</span> <span class="o">=</span> <span class="mf">7.2921150e-5</span>  <span class="c1"># rad/s Earth rotation rate</span>
    <span class="n">r</span> <span class="o">=</span> <span class="mf">6371.e3</span>  <span class="c1"># Earth radius</span>
    <span class="c1"># Coriolis parameter f = 2 Omega sin(alpha)</span>
    <span class="c1"># Beta plane approximation f_beta = f_0 + Beta y</span>
    <span class="c1"># f_0 = 2 Omega sin(alpha_0)</span>
    <span class="c1"># Beta = df/dy|_{alpha=alpha_0}</span>
    <span class="c1">#      = (df/dalpha*dalpha/dy)_{alpha=alpha_0}</span>
    <span class="c1">#      = 2 Omega cos(alpha_0) /R</span>
    <span class="n">alpha_0</span> <span class="o">=</span> <span class="mi">2</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">pi</span><span class="o">*</span><span class="n">latitude</span><span class="o">/</span><span class="mf">360.0</span>
    <span class="n">f_0</span> <span class="o">=</span> <span class="mi">2</span><span class="o">*</span><span class="n">omega</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="n">alpha_0</span><span class="p">)</span>
    <span class="n">beta</span> <span class="o">=</span> <span class="mi">2</span><span class="o">*</span><span class="n">omega</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">cos</span><span class="p">(</span><span class="n">alpha_0</span><span class="p">)</span><span class="o">/</span><span class="n">r</span>
    <span class="k">return</span> <span class="n">f_0</span><span class="p">,</span> <span class="n">beta</span></div>


<div class="viewcode-block" id="beta_plane_coriolis_function"><a class="viewcode-back" href="../../thetis.html#thetis.utility.beta_plane_coriolis_function">[docs]</a><span class="k">def</span> <span class="nf">beta_plane_coriolis_function</span><span class="p">(</span><span class="n">latitude</span><span class="p">,</span> <span class="n">out_function</span><span class="p">,</span> <span class="n">y_offset</span><span class="o">=</span><span class="mf">0.0</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Interpolates beta plane Coriolis function to a field</span>

<span class="sd">    :arg float latitude: latitude in degrees</span>
<span class="sd">    :arg out_function: :class:`Function` where to interpolate</span>
<span class="sd">    :kwarg float y_offset: offset (y - y_0) used in Beta-plane approximation.</span>
<span class="sd">        A constant in mesh coordinates.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1"># NOTE assumes that mesh y coordinate spans [-L_y, L_y]</span>
    <span class="n">f0</span><span class="p">,</span> <span class="n">beta</span> <span class="o">=</span> <span class="n">beta_plane_coriolis_params</span><span class="p">(</span><span class="n">latitude</span><span class="p">)</span>
    <span class="n">out_function</span><span class="o">.</span><span class="n">interpolate</span><span class="p">(</span>
        <span class="n">Expression</span><span class="p">(</span><span class="s1">&#39;f0+beta*(x[1]-y_0)&#39;</span><span class="p">,</span> <span class="n">f0</span><span class="o">=</span><span class="n">f0</span><span class="p">,</span> <span class="n">beta</span><span class="o">=</span><span class="n">beta</span><span class="p">,</span> <span class="n">y_0</span><span class="o">=</span><span class="n">y_offset</span><span class="p">))</span></div>


<div class="viewcode-block" id="SmagorinskyViscosity"><a class="viewcode-back" href="../../thetis.html#thetis.utility.SmagorinskyViscosity">[docs]</a><span class="k">class</span> <span class="nc">SmagorinskyViscosity</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>
    <span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Computes Smagorinsky subgrid scale horizontal viscosity</span>

<span class="sd">    This formulation is according to Ilicak et al. (2012) and</span>
<span class="sd">    Griffies and Hallberg (2000).</span>

<span class="sd">    .. math::</span>
<span class="sd">        \nu = (C_s \Delta x)^2 |S|</span>

<span class="sd">    with the deformation rate</span>

<span class="sd">    .. math::</span>
<span class="sd">        |S| &amp;= \sqrt{D_T^2 + D_S^2} \\</span>
<span class="sd">        D_T &amp;= \frac{\partial u}{\partial x} - \frac{\partial v}{\partial y} \\</span>
<span class="sd">        D_S &amp;= \frac{\partial u}{\partial y} + \frac{\partial v}{\partial x}</span>

<span class="sd">    :math:`\Delta x` is the horizontal element size and :math:`C_s` is the</span>
<span class="sd">    Smagorinsky coefficient.</span>

<span class="sd">    To match a certain mesh Reynolds number :math:`Re_h` set</span>
<span class="sd">    :math:`C_s = 1/\sqrt{Re_h}`.</span>

<span class="sd">    Ilicak et al. (2012). Spurious dianeutral mixing and the role of</span>
<span class="sd">    momentum closure. Ocean Modelling, 45-46(0):37-58.</span>
<span class="sd">    http://dx.doi.org/10.1016/j.ocemod.2011.10.003</span>

<span class="sd">    Griffies and Hallberg (2000). Biharmonic friction with a</span>
<span class="sd">    Smagorinsky-like viscosity for use in large-scale eddy-permitting</span>
<span class="sd">    ocean models. Monthly Weather Review, 128(8):2935-2946.</span>
<span class="sd">    http://dx.doi.org/10.1175/1520-0493(2000)128%3C2935:BFWASL%3E2.0.CO;2</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">uv</span><span class="p">,</span> <span class="n">output</span><span class="p">,</span> <span class="n">c_s</span><span class="p">,</span> <span class="n">h_elem_size</span><span class="p">,</span> <span class="n">max_val</span><span class="p">,</span> <span class="n">min_val</span><span class="o">=</span><span class="mf">1e-10</span><span class="p">,</span>
                 <span class="n">weak_form</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">solver_parameters</span><span class="o">=</span><span class="p">{}):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        :arg uv_3d: horizontal velocity</span>
<span class="sd">        :type uv_3d: 3D vector :class:`Function`</span>
<span class="sd">        :arg output: Smagorinsky viscosity field</span>
<span class="sd">        :type output: 3D scalar :class:`Function`</span>
<span class="sd">        :arg c_s: Smagorinsky coefficient</span>
<span class="sd">        :type c_s: float or :class:`Constant`</span>
<span class="sd">        :arg h_elem_size: field that defines the horizontal element size</span>
<span class="sd">        :type h_elem_size: 3D scalar :class:`Function` or :class:`Constant`</span>
<span class="sd">        :arg float max_val: Maximum allowed viscosity. Viscosity will be clipped at</span>
<span class="sd">            this value.</span>
<span class="sd">        :kwarg float min_val: Minimum allowed viscosity. Viscosity will be clipped at</span>
<span class="sd">            this value.</span>
<span class="sd">        :kwarg bool weak_form: Compute velocity shear by integrating by parts.</span>
<span class="sd">            Necessary for some function spaces (e.g. P0).</span>
<span class="sd">        :kwarg dict solver_parameters: PETSc solver options</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">solver_parameters</span><span class="o">.</span><span class="n">setdefault</span><span class="p">(</span><span class="s1">&#39;ksp_atol&#39;</span><span class="p">,</span> <span class="mf">1e-12</span><span class="p">)</span>
        <span class="n">solver_parameters</span><span class="o">.</span><span class="n">setdefault</span><span class="p">(</span><span class="s1">&#39;ksp_rtol&#39;</span><span class="p">,</span> <span class="mf">1e-16</span><span class="p">)</span>
        <span class="k">assert</span> <span class="n">max_val</span><span class="o">.</span><span class="n">function_space</span><span class="p">()</span> <span class="o">==</span> <span class="n">output</span><span class="o">.</span><span class="n">function_space</span><span class="p">(),</span> \
            <span class="s1">&#39;max_val function must belong to the same space as output&#39;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">max_val</span> <span class="o">=</span> <span class="n">max_val</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">min_val</span> <span class="o">=</span> <span class="n">min_val</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">output</span> <span class="o">=</span> <span class="n">output</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">weak_form</span> <span class="o">=</span> <span class="n">weak_form</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">weak_form</span><span class="p">:</span>
            <span class="c1"># solve grad(u) weakly</span>
            <span class="n">mesh</span> <span class="o">=</span> <span class="n">output</span><span class="o">.</span><span class="n">function_space</span><span class="p">()</span><span class="o">.</span><span class="n">mesh</span><span class="p">()</span>
            <span class="n">fs_grad</span> <span class="o">=</span> <span class="n">FunctionSpace</span><span class="p">(</span><span class="n">mesh</span><span class="p">,</span> <span class="s1">&#39;DP&#39;</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="n">vfamily</span><span class="o">=</span><span class="s1">&#39;DP&#39;</span><span class="p">,</span> <span class="n">vdegree</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">grad</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="k">for</span> <span class="n">icomp</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">2</span><span class="p">):</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">grad</span><span class="p">[</span><span class="n">icomp</span><span class="p">]</span> <span class="o">=</span> <span class="p">[]</span>
                <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">2</span><span class="p">):</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">grad</span><span class="p">[</span><span class="n">icomp</span><span class="p">][</span><span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="n">Function</span><span class="p">(</span><span class="n">fs_grad</span><span class="p">,</span> <span class="n">name</span><span class="o">=</span><span class="s1">&#39;uv_grad(</span><span class="si">{:}</span><span class="s1">,</span><span class="si">{:}</span><span class="s1">)&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">icomp</span><span class="p">,</span> <span class="n">j</span><span class="p">))</span>

            <span class="n">tri_grad</span> <span class="o">=</span> <span class="n">TrialFunction</span><span class="p">(</span><span class="n">fs_grad</span><span class="p">)</span>
            <span class="n">test_grad</span> <span class="o">=</span> <span class="n">TestFunction</span><span class="p">(</span><span class="n">fs_grad</span><span class="p">)</span>

            <span class="n">normal</span> <span class="o">=</span> <span class="n">FacetNormal</span><span class="p">(</span><span class="n">mesh</span><span class="p">)</span>
            <span class="n">a</span> <span class="o">=</span> <span class="n">inner</span><span class="p">(</span><span class="n">tri_grad</span><span class="p">,</span> <span class="n">test_grad</span><span class="p">)</span><span class="o">*</span><span class="n">dx</span>

            <span class="bp">self</span><span class="o">.</span><span class="n">solver_grad</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="k">for</span> <span class="n">icomp</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">2</span><span class="p">):</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">solver_grad</span><span class="p">[</span><span class="n">icomp</span><span class="p">]</span> <span class="o">=</span> <span class="p">[]</span>
                <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">2</span><span class="p">):</span>
                    <span class="n">a</span> <span class="o">=</span> <span class="n">inner</span><span class="p">(</span><span class="n">tri_grad</span><span class="p">,</span> <span class="n">test_grad</span><span class="p">)</span><span class="o">*</span><span class="n">dx</span>
                    <span class="c1"># l = inner(Dx(uv[0], 0), test_grad)*dx</span>
                    <span class="n">l</span> <span class="o">=</span> <span class="o">-</span><span class="n">inner</span><span class="p">(</span><span class="n">Dx</span><span class="p">(</span><span class="n">test_grad</span><span class="p">,</span> <span class="n">j</span><span class="p">),</span> <span class="n">uv</span><span class="p">[</span><span class="n">icomp</span><span class="p">])</span><span class="o">*</span><span class="n">dx</span>
                    <span class="n">l</span> <span class="o">+=</span> <span class="n">inner</span><span class="p">(</span><span class="n">avg</span><span class="p">(</span><span class="n">uv</span><span class="p">[</span><span class="n">icomp</span><span class="p">]),</span> <span class="n">jump</span><span class="p">(</span><span class="n">test_grad</span><span class="p">,</span> <span class="n">normal</span><span class="p">[</span><span class="n">j</span><span class="p">]))</span><span class="o">*</span><span class="n">dS_v</span>
                    <span class="n">l</span> <span class="o">+=</span> <span class="n">inner</span><span class="p">(</span><span class="n">uv</span><span class="p">[</span><span class="n">icomp</span><span class="p">],</span> <span class="n">test_grad</span><span class="o">*</span><span class="n">normal</span><span class="p">[</span><span class="n">j</span><span class="p">])</span><span class="o">*</span><span class="n">ds_v</span>
                    <span class="n">prob</span> <span class="o">=</span> <span class="n">LinearVariationalProblem</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">l</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">grad</span><span class="p">[</span><span class="n">icomp</span><span class="p">][</span><span class="n">j</span><span class="p">])</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">solver_grad</span><span class="p">[</span><span class="n">icomp</span><span class="p">][</span><span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="n">LinearVariationalSolver</span><span class="p">(</span><span class="n">prob</span><span class="p">,</span> <span class="n">solver_parameters</span><span class="o">=</span><span class="n">solver_parameters</span><span class="p">)</span>

        <span class="n">fs</span> <span class="o">=</span> <span class="n">output</span><span class="o">.</span><span class="n">function_space</span><span class="p">()</span>
        <span class="n">tri</span> <span class="o">=</span> <span class="n">TrialFunction</span><span class="p">(</span><span class="n">fs</span><span class="p">)</span>
        <span class="n">test</span> <span class="o">=</span> <span class="n">TestFunction</span><span class="p">(</span><span class="n">fs</span><span class="p">)</span>

        <span class="c1"># rate of strain tensor</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">weak_form</span><span class="p">:</span>
            <span class="n">d_t</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">grad</span><span class="p">[(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">)]</span> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">grad</span><span class="p">[(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">)]</span>
            <span class="n">d_s</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">grad</span><span class="p">[(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">)]</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">grad</span><span class="p">[(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">)]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">d_t</span> <span class="o">=</span> <span class="n">Dx</span><span class="p">(</span><span class="n">uv</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="mi">0</span><span class="p">)</span> <span class="o">-</span> <span class="n">Dx</span><span class="p">(</span><span class="n">uv</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="mi">1</span><span class="p">)</span>
            <span class="n">d_s</span> <span class="o">=</span> <span class="n">Dx</span><span class="p">(</span><span class="n">uv</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="mi">1</span><span class="p">)</span> <span class="o">+</span> <span class="n">Dx</span><span class="p">(</span><span class="n">uv</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="mi">0</span><span class="p">)</span>
        <span class="n">nu</span> <span class="o">=</span> <span class="n">c_s</span><span class="o">**</span><span class="mi">2</span><span class="o">*</span><span class="n">h_elem_size</span><span class="o">**</span><span class="mi">2</span> <span class="o">*</span> <span class="n">sqrt</span><span class="p">(</span><span class="n">d_t</span><span class="o">**</span><span class="mi">2</span> <span class="o">+</span> <span class="n">d_s</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span>

        <span class="n">a</span> <span class="o">=</span> <span class="n">test</span><span class="o">*</span><span class="n">tri</span><span class="o">*</span><span class="n">dx</span>
        <span class="n">l</span> <span class="o">=</span> <span class="n">test</span><span class="o">*</span><span class="n">nu</span><span class="o">*</span><span class="n">dx</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">prob</span> <span class="o">=</span> <span class="n">LinearVariationalProblem</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">l</span><span class="p">,</span> <span class="n">output</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">solver</span> <span class="o">=</span> <span class="n">LinearVariationalSolver</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">prob</span><span class="p">,</span> <span class="n">solver_parameters</span><span class="o">=</span><span class="n">solver_parameters</span><span class="p">)</span>

<div class="viewcode-block" id="SmagorinskyViscosity.solve"><a class="viewcode-back" href="../../thetis.html#thetis.utility.SmagorinskyViscosity.solve">[docs]</a>    <span class="k">def</span> <span class="nf">solve</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Compute viscosity&quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">weak_form</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">icomp</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">2</span><span class="p">):</span>
                <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">2</span><span class="p">):</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">solver_grad</span><span class="p">[</span><span class="n">icomp</span><span class="p">][</span><span class="n">j</span><span class="p">]</span><span class="o">.</span><span class="n">solve</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">solver</span><span class="o">.</span><span class="n">solve</span><span class="p">()</span>
        <span class="c1"># remove negative values</span>
        <span class="n">ix</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">output</span><span class="o">.</span><span class="n">dat</span><span class="o">.</span><span class="n">data</span> <span class="o">&lt;</span> <span class="bp">self</span><span class="o">.</span><span class="n">min_val</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">output</span><span class="o">.</span><span class="n">dat</span><span class="o">.</span><span class="n">data</span><span class="p">[</span><span class="n">ix</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">min_val</span>

        <span class="c1"># crop too large values</span>
        <span class="n">ix</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">output</span><span class="o">.</span><span class="n">dat</span><span class="o">.</span><span class="n">data</span> <span class="o">&gt;</span> <span class="bp">self</span><span class="o">.</span><span class="n">max_val</span><span class="o">.</span><span class="n">dat</span><span class="o">.</span><span class="n">data</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">output</span><span class="o">.</span><span class="n">dat</span><span class="o">.</span><span class="n">data</span><span class="p">[</span><span class="n">ix</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">max_val</span><span class="o">.</span><span class="n">dat</span><span class="o">.</span><span class="n">data</span><span class="p">[</span><span class="n">ix</span><span class="p">]</span></div></div>


<div class="viewcode-block" id="EquationOfState"><a class="viewcode-back" href="../../thetis.html#thetis.utility.EquationOfState">[docs]</a><span class="k">class</span> <span class="nc">EquationOfState</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Base class of all equation of state objects</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">__metaclass__</span> <span class="o">=</span> <span class="n">ABCMeta</span>

<div class="viewcode-block" id="EquationOfState.compute_rho"><a class="viewcode-back" href="../../thetis.html#thetis.utility.EquationOfState.compute_rho">[docs]</a>    <span class="nd">@abstractmethod</span>
    <span class="k">def</span> <span class="nf">compute_rho</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">s</span><span class="p">,</span> <span class="n">th</span><span class="p">,</span> <span class="n">p</span><span class="p">,</span> <span class="n">rho0</span><span class="o">=</span><span class="mf">0.0</span><span class="p">):</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Compute sea water density.</span>

<span class="sd">        :arg s: Salinity expressed on the Practical Salinity Scale 1978</span>
<span class="sd">        :type s: float or numpy.array</span>
<span class="sd">        :arg th: Potential temperature in Celsius, referenced to pressure</span>
<span class="sd">            p_r = 0 dbar.</span>
<span class="sd">        :type th: float or numpy.array</span>
<span class="sd">        :arg p: Pressure in decibars (1 dbar = 1e4 Pa)</span>
<span class="sd">        :type p: float or numpy.array</span>
<span class="sd">        :kwarg float rho0: Optional reference density. If provided computes</span>
<span class="sd">            :math:`\rho&#39; = \rho(S, Th, p) - \rho_0`</span>
<span class="sd">        :return: water density</span>
<span class="sd">        :rtype: float or numpy.array</span>

<span class="sd">        All pressures are gauge pressures: they are the absolute pressures minus standard atmosperic</span>
<span class="sd">        pressure 10.1325 dbar.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">pass</span></div>

<div class="viewcode-block" id="EquationOfState.eval"><a class="viewcode-back" href="../../thetis.html#thetis.utility.EquationOfState.eval">[docs]</a>    <span class="nd">@abstractmethod</span>
    <span class="k">def</span> <span class="nf">eval</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">s</span><span class="p">,</span> <span class="n">th</span><span class="p">,</span> <span class="n">p</span><span class="p">,</span> <span class="n">rho0</span><span class="o">=</span><span class="mf">0.0</span><span class="p">):</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Compute sea water density.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">pass</span></div></div>


<div class="viewcode-block" id="JackettEquationOfState"><a class="viewcode-back" href="../../thetis.html#thetis.utility.JackettEquationOfState">[docs]</a><span class="k">class</span> <span class="nc">JackettEquationOfState</span><span class="p">(</span><span class="n">EquationOfState</span><span class="p">):</span>
    <span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Equation of State according of Jackett et al. (2006) for computing sea</span>
<span class="sd">    water density.</span>

<span class="sd">    .. math ::</span>
<span class="sd">        \rho = \rho&#39;(T, S, p) + \rho_0</span>
<span class="sd">        :label: equation_of_state</span>

<span class="sd">    :math:`\rho&#39;(T, S, p)` is a nonlinear rational function.</span>

<span class="sd">    Jackett et al. (2006). Algorithms for Density, Potential Temperature,</span>
<span class="sd">    Conservative Temperature, and the Freezing Temperature of Seawater.</span>
<span class="sd">    Journal of Atmospheric and Oceanic Technology, 23(12):1709-1728.</span>
<span class="sd">    http://dx.doi.org/10.1175/JTECH1946.1</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">a</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mf">9.9984085444849347e2</span><span class="p">,</span> <span class="mf">7.3471625860981584e0</span><span class="p">,</span> <span class="o">-</span><span class="mf">5.3211231792841769e-2</span><span class="p">,</span>
                  <span class="mf">3.6492439109814549e-4</span><span class="p">,</span> <span class="mf">2.5880571023991390e0</span><span class="p">,</span> <span class="o">-</span><span class="mf">6.7168282786692355e-3</span><span class="p">,</span>
                  <span class="mf">1.9203202055760151e-3</span><span class="p">,</span> <span class="mf">1.1798263740430364e-2</span><span class="p">,</span> <span class="mf">9.8920219266399117e-8</span><span class="p">,</span>
                  <span class="mf">4.6996642771754730e-6</span><span class="p">,</span> <span class="o">-</span><span class="mf">2.5862187075154352e-8</span><span class="p">,</span> <span class="o">-</span><span class="mf">3.2921414007960662e-12</span><span class="p">])</span>
    <span class="n">b</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mf">1.0</span><span class="p">,</span> <span class="mf">7.2815210113327091e-3</span><span class="p">,</span> <span class="o">-</span><span class="mf">4.4787265461983921e-5</span><span class="p">,</span> <span class="mf">3.3851002965802430e-7</span><span class="p">,</span>
                  <span class="mf">1.3651202389758572e-10</span><span class="p">,</span> <span class="mf">1.7632126669040377e-3</span><span class="p">,</span> <span class="o">-</span><span class="mf">8.8066583251206474e-6</span><span class="p">,</span>
                  <span class="o">-</span><span class="mf">1.8832689434804897e-10</span><span class="p">,</span> <span class="mf">5.7463776745432097e-6</span><span class="p">,</span> <span class="mf">1.4716275472242334e-9</span><span class="p">,</span>
                  <span class="mf">6.7103246285651894e-6</span><span class="p">,</span> <span class="o">-</span><span class="mf">2.4461698007024582e-17</span><span class="p">,</span> <span class="o">-</span><span class="mf">9.1534417604289062e-18</span><span class="p">])</span>

<div class="viewcode-block" id="JackettEquationOfState.compute_rho"><a class="viewcode-back" href="../../thetis.html#thetis.utility.JackettEquationOfState.compute_rho">[docs]</a>    <span class="k">def</span> <span class="nf">compute_rho</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">s</span><span class="p">,</span> <span class="n">th</span><span class="p">,</span> <span class="n">p</span><span class="p">,</span> <span class="n">rho0</span><span class="o">=</span><span class="mf">0.0</span><span class="p">):</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Compute sea water density.</span>

<span class="sd">        :arg s: Salinity expressed on the Practical Salinity Scale 1978</span>
<span class="sd">        :type s: float or numpy.array</span>
<span class="sd">        :arg th: Potential temperature in Celsius, referenced to pressure</span>
<span class="sd">            p_r = 0 dbar.</span>
<span class="sd">        :type th: float or numpy.array</span>
<span class="sd">        :arg p: Pressure in decibars (1 dbar = 1e4 Pa)</span>
<span class="sd">        :type p: float or numpy.array</span>
<span class="sd">        :kwarg float rho0: Optional reference density. If provided computes</span>
<span class="sd">            :math:`\rho&#39; = \rho(S, Th, p) - \rho_0`</span>
<span class="sd">        :return: water density</span>
<span class="sd">        :rtype: float or numpy.array</span>

<span class="sd">        All pressures are gauge pressures: they are the absolute pressures minus standard atmosperic</span>
<span class="sd">        pressure 10.1325 dbar.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">s_pos</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">maximum</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="mf">0.0</span><span class="p">)</span>  <span class="c1"># ensure salinity is positive</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">eval</span><span class="p">(</span><span class="n">s_pos</span><span class="p">,</span> <span class="n">th</span><span class="p">,</span> <span class="n">p</span><span class="p">,</span> <span class="n">rho0</span><span class="p">)</span></div>

<div class="viewcode-block" id="JackettEquationOfState.eval"><a class="viewcode-back" href="../../thetis.html#thetis.utility.JackettEquationOfState.eval">[docs]</a>    <span class="k">def</span> <span class="nf">eval</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">s</span><span class="p">,</span> <span class="n">th</span><span class="p">,</span> <span class="n">p</span><span class="p">,</span> <span class="n">rho0</span><span class="o">=</span><span class="mf">0.0</span><span class="p">):</span>
        <span class="n">a</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">a</span>
        <span class="n">b</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">b</span>
        <span class="n">pn</span> <span class="o">=</span> <span class="p">(</span><span class="n">a</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">+</span> <span class="n">th</span><span class="o">*</span><span class="n">a</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">+</span> <span class="n">th</span><span class="o">*</span><span class="n">th</span><span class="o">*</span><span class="n">a</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">+</span> <span class="n">th</span><span class="o">*</span><span class="n">th</span><span class="o">*</span><span class="n">th</span><span class="o">*</span><span class="n">a</span><span class="p">[</span><span class="mi">3</span><span class="p">]</span> <span class="o">+</span> <span class="n">s</span><span class="o">*</span><span class="n">a</span><span class="p">[</span><span class="mi">4</span><span class="p">]</span> <span class="o">+</span>
              <span class="n">th</span><span class="o">*</span><span class="n">s</span><span class="o">*</span><span class="n">a</span><span class="p">[</span><span class="mi">5</span><span class="p">]</span> <span class="o">+</span> <span class="n">s</span><span class="o">*</span><span class="n">s</span><span class="o">*</span><span class="n">a</span><span class="p">[</span><span class="mi">6</span><span class="p">]</span> <span class="o">+</span> <span class="n">p</span><span class="o">*</span><span class="n">a</span><span class="p">[</span><span class="mi">7</span><span class="p">]</span> <span class="o">+</span> <span class="n">p</span><span class="o">*</span><span class="n">th</span> <span class="o">*</span> <span class="n">th</span><span class="o">*</span><span class="n">a</span><span class="p">[</span><span class="mi">8</span><span class="p">]</span> <span class="o">+</span> <span class="n">p</span><span class="o">*</span><span class="n">s</span><span class="o">*</span><span class="n">a</span><span class="p">[</span><span class="mi">9</span><span class="p">]</span> <span class="o">+</span>
              <span class="n">p</span><span class="o">*</span><span class="n">p</span><span class="o">*</span><span class="n">a</span><span class="p">[</span><span class="mi">10</span><span class="p">]</span> <span class="o">+</span> <span class="n">p</span><span class="o">*</span><span class="n">p</span><span class="o">*</span><span class="n">th</span><span class="o">*</span><span class="n">th</span> <span class="o">*</span> <span class="n">a</span><span class="p">[</span><span class="mi">11</span><span class="p">])</span>
        <span class="n">pd</span> <span class="o">=</span> <span class="p">(</span><span class="n">b</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">+</span> <span class="n">th</span><span class="o">*</span><span class="n">b</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">+</span> <span class="n">th</span><span class="o">*</span><span class="n">th</span><span class="o">*</span><span class="n">b</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">+</span> <span class="n">th</span><span class="o">*</span><span class="n">th</span><span class="o">*</span><span class="n">th</span><span class="o">*</span><span class="n">b</span><span class="p">[</span><span class="mi">3</span><span class="p">]</span> <span class="o">+</span>
              <span class="n">th</span><span class="o">*</span><span class="n">th</span><span class="o">*</span><span class="n">th</span><span class="o">*</span><span class="n">th</span><span class="o">*</span><span class="n">b</span><span class="p">[</span><span class="mi">4</span><span class="p">]</span> <span class="o">+</span> <span class="n">s</span><span class="o">*</span><span class="n">b</span><span class="p">[</span><span class="mi">5</span><span class="p">]</span> <span class="o">+</span> <span class="n">s</span><span class="o">*</span><span class="n">th</span><span class="o">*</span><span class="n">b</span><span class="p">[</span><span class="mi">6</span><span class="p">]</span> <span class="o">+</span> <span class="n">s</span><span class="o">*</span><span class="n">th</span><span class="o">*</span><span class="n">th</span><span class="o">*</span><span class="n">th</span><span class="o">*</span><span class="n">b</span><span class="p">[</span><span class="mi">7</span><span class="p">]</span> <span class="o">+</span>
              <span class="nb">pow</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="mf">1.5</span><span class="p">)</span><span class="o">*</span><span class="n">b</span><span class="p">[</span><span class="mi">8</span><span class="p">]</span> <span class="o">+</span> <span class="nb">pow</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="mf">1.5</span><span class="p">)</span><span class="o">*</span><span class="n">th</span><span class="o">*</span><span class="n">th</span><span class="o">*</span><span class="n">b</span><span class="p">[</span><span class="mi">9</span><span class="p">]</span> <span class="o">+</span> <span class="n">p</span><span class="o">*</span><span class="n">b</span><span class="p">[</span><span class="mi">10</span><span class="p">]</span> <span class="o">+</span>
              <span class="n">p</span><span class="o">*</span><span class="n">p</span><span class="o">*</span><span class="n">th</span><span class="o">*</span><span class="n">th</span><span class="o">*</span><span class="n">th</span><span class="o">*</span><span class="n">b</span><span class="p">[</span><span class="mi">11</span><span class="p">]</span> <span class="o">+</span> <span class="n">p</span><span class="o">*</span><span class="n">p</span><span class="o">*</span><span class="n">p</span><span class="o">*</span><span class="n">th</span><span class="o">*</span><span class="n">b</span><span class="p">[</span><span class="mi">12</span><span class="p">])</span>
        <span class="n">rho</span> <span class="o">=</span> <span class="n">pn</span><span class="o">/</span><span class="n">pd</span> <span class="o">-</span> <span class="n">rho0</span>
        <span class="k">return</span> <span class="n">rho</span></div></div>


<div class="viewcode-block" id="LinearEquationOfState"><a class="viewcode-back" href="../../thetis.html#thetis.utility.LinearEquationOfState">[docs]</a><span class="k">class</span> <span class="nc">LinearEquationOfState</span><span class="p">(</span><span class="n">EquationOfState</span><span class="p">):</span>
    <span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Linear Equation of State for computing sea water density</span>

<span class="sd">    .. math::</span>
<span class="sd">        \rho = \rho_{ref} - \alpha (T - T_{ref}) + \beta (S - S_{ref})</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">rho_ref</span><span class="p">,</span> <span class="n">alpha</span><span class="p">,</span> <span class="n">beta</span><span class="p">,</span> <span class="n">th_ref</span><span class="p">,</span> <span class="n">s_ref</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        :arg float rho_ref: reference density</span>
<span class="sd">        :arg float alpha: thermal expansion coefficient</span>
<span class="sd">        :arg float beta: haline contraction coefficient</span>
<span class="sd">        :arg float th_ref: reference temperature</span>
<span class="sd">        :arg float s_ref: reference salinity</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">rho_ref</span> <span class="o">=</span> <span class="n">rho_ref</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">alpha</span> <span class="o">=</span> <span class="n">alpha</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">beta</span> <span class="o">=</span> <span class="n">beta</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">th_ref</span> <span class="o">=</span> <span class="n">th_ref</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">S_ref</span> <span class="o">=</span> <span class="n">s_ref</span>

<div class="viewcode-block" id="LinearEquationOfState.compute_rho"><a class="viewcode-back" href="../../thetis.html#thetis.utility.LinearEquationOfState.compute_rho">[docs]</a>    <span class="k">def</span> <span class="nf">compute_rho</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">s</span><span class="p">,</span> <span class="n">th</span><span class="p">,</span> <span class="n">p</span><span class="p">,</span> <span class="n">rho0</span><span class="o">=</span><span class="mf">0.0</span><span class="p">):</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Compute sea water density.</span>

<span class="sd">        :arg s: Salinity expressed on the Practical Salinity Scale 1978</span>
<span class="sd">        :type s: float or numpy.array</span>
<span class="sd">        :arg th: Potential temperature in Celsius</span>
<span class="sd">        :type th: float or numpy.array</span>
<span class="sd">        :arg p: Pressure in decibars (1 dbar = 1e4 Pa)</span>
<span class="sd">        :type p: float or numpy.array</span>
<span class="sd">        :kwarg float rho0: Optional reference density. If provided computes</span>
<span class="sd">            :math:`\rho&#39; = \rho(S, Th, p) - \rho_0`</span>
<span class="sd">        :return: water density</span>
<span class="sd">        :rtype: float or numpy.array</span>

<span class="sd">        Pressure is ingored in this equation of state.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">rho</span> <span class="o">=</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">rho_ref</span> <span class="o">-</span> <span class="n">rho0</span> <span class="o">-</span>
               <span class="bp">self</span><span class="o">.</span><span class="n">alpha</span><span class="o">*</span><span class="p">(</span><span class="n">th</span> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">th_ref</span><span class="p">)</span> <span class="o">+</span>
               <span class="bp">self</span><span class="o">.</span><span class="n">beta</span><span class="o">*</span><span class="p">(</span><span class="n">s</span> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">S_ref</span><span class="p">))</span>
        <span class="k">return</span> <span class="n">rho</span></div>

<div class="viewcode-block" id="LinearEquationOfState.eval"><a class="viewcode-back" href="../../thetis.html#thetis.utility.LinearEquationOfState.eval">[docs]</a>    <span class="k">def</span> <span class="nf">eval</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">s</span><span class="p">,</span> <span class="n">th</span><span class="p">,</span> <span class="n">p</span><span class="p">,</span> <span class="n">rho0</span><span class="o">=</span><span class="mf">0.0</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">compute_rho</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="n">th</span><span class="p">,</span> <span class="n">p</span><span class="p">,</span> <span class="n">rho0</span><span class="p">)</span></div></div>


<div class="viewcode-block" id="tensor_jump"><a class="viewcode-back" href="../../thetis.html#thetis.utility.tensor_jump">[docs]</a><span class="k">def</span> <span class="nf">tensor_jump</span><span class="p">(</span><span class="n">v</span><span class="p">,</span> <span class="n">n</span><span class="p">):</span>
    <span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Jump term for vector functions based on the tensor product</span>

<span class="sd">    .. math::</span>
<span class="sd">        \text{jump}(\mathbf{u}, \mathbf{n}) = (\mathbf{u}^+ \mathbf{n}^+) +</span>
<span class="sd">        (\mathbf{u}^- \mathbf{n}^-)</span>

<span class="sd">    This is the discrete equivalent of grad(u) as opposed to the</span>
<span class="sd">    vectorial UFL jump operator :meth:`ufl.jump` which represents div(u).</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">outer</span><span class="p">(</span><span class="n">v</span><span class="p">(</span><span class="s1">&#39;+&#39;</span><span class="p">),</span> <span class="n">n</span><span class="p">(</span><span class="s1">&#39;+&#39;</span><span class="p">))</span> <span class="o">+</span> <span class="n">outer</span><span class="p">(</span><span class="n">v</span><span class="p">(</span><span class="s1">&#39;-&#39;</span><span class="p">),</span> <span class="n">n</span><span class="p">(</span><span class="s1">&#39;-&#39;</span><span class="p">))</span></div>


<div class="viewcode-block" id="compute_boundary_length"><a class="viewcode-back" href="../../thetis.html#thetis.utility.compute_boundary_length">[docs]</a><span class="k">def</span> <span class="nf">compute_boundary_length</span><span class="p">(</span><span class="n">mesh2d</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Computes the length of the boundary segments in given 2d mesh</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">p1</span> <span class="o">=</span> <span class="n">FunctionSpace</span><span class="p">(</span><span class="n">mesh2d</span><span class="p">,</span> <span class="s1">&#39;CG&#39;</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
    <span class="n">boundary_markers</span> <span class="o">=</span> <span class="nb">sorted</span><span class="p">(</span><span class="n">mesh2d</span><span class="o">.</span><span class="n">exterior_facets</span><span class="o">.</span><span class="n">unique_markers</span><span class="p">)</span>
    <span class="n">boundary_len</span> <span class="o">=</span> <span class="n">OrderedDict</span><span class="p">()</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">boundary_markers</span><span class="p">:</span>
        <span class="n">ds_restricted</span> <span class="o">=</span> <span class="n">ds</span><span class="p">(</span><span class="nb">int</span><span class="p">(</span><span class="n">i</span><span class="p">))</span>
        <span class="n">one_func</span> <span class="o">=</span> <span class="n">Function</span><span class="p">(</span><span class="n">p1</span><span class="p">)</span><span class="o">.</span><span class="n">assign</span><span class="p">(</span><span class="mf">1.0</span><span class="p">)</span>
        <span class="n">boundary_len</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">assemble</span><span class="p">(</span><span class="n">one_func</span> <span class="o">*</span> <span class="n">ds_restricted</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">boundary_len</span></div>


<div class="viewcode-block" id="select_and_move_detectors"><a class="viewcode-back" href="../../thetis.html#thetis.utility.select_and_move_detectors">[docs]</a><span class="k">def</span> <span class="nf">select_and_move_detectors</span><span class="p">(</span><span class="n">mesh</span><span class="p">,</span> <span class="n">detector_locations</span><span class="p">,</span> <span class="n">detector_names</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                              <span class="n">maximum_distance</span><span class="o">=</span><span class="mf">0.</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Select those detectors that are within the domain and/or move them to</span>
<span class="sd">    the nearest cell centre within the domain</span>

<span class="sd">    :arg mesh: Defines the domain in which detectors are to be located</span>
<span class="sd">    :arg detector_locations: List of x, y locations</span>
<span class="sd">    :arg detector_names: List of detector names (optional). If provided, a list</span>
<span class="sd">       of selected locations and a list of selected detector names are returned,</span>
<span class="sd">       otherwise only a list of selected locations is returned</span>
<span class="sd">    :arg maximum_distance: Detectors whose initial locations is outside the domain,</span>
<span class="sd">      but for which the nearest cell centre is within the specified distance, are</span>
<span class="sd">      moved to this location. By default a maximum distance of 0.0 is used, i.e</span>
<span class="sd">      no detectors are moved.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1"># auxilary function to test whether we can interpolate it in the given locations</span>
    <span class="n">V</span> <span class="o">=</span> <span class="n">FunctionSpace</span><span class="p">(</span><span class="n">mesh</span><span class="p">,</span> <span class="s2">&quot;CG&quot;</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
    <span class="n">v</span> <span class="o">=</span> <span class="n">Function</span><span class="p">(</span><span class="n">V</span><span class="p">)</span>

    <span class="n">P0</span> <span class="o">=</span> <span class="n">FunctionSpace</span><span class="p">(</span><span class="n">mesh</span><span class="p">,</span> <span class="s2">&quot;DG&quot;</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
    <span class="n">VP0</span> <span class="o">=</span> <span class="n">VectorFunctionSpace</span><span class="p">(</span><span class="n">mesh</span><span class="p">,</span> <span class="s2">&quot;DG&quot;</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
    <span class="n">dist</span> <span class="o">=</span> <span class="n">Function</span><span class="p">(</span><span class="n">P0</span><span class="p">)</span>
    <span class="n">loc_const</span> <span class="o">=</span> <span class="n">Constant</span><span class="p">(</span><span class="n">detector_locations</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
    <span class="n">xy</span> <span class="o">=</span> <span class="n">SpatialCoordinate</span><span class="p">(</span><span class="n">mesh</span><span class="p">)</span>
    <span class="n">p0xy</span> <span class="o">=</span> <span class="n">Function</span><span class="p">(</span><span class="n">VP0</span><span class="p">)</span><span class="o">.</span><span class="n">interpolate</span><span class="p">(</span><span class="n">xy</span><span class="p">)</span>

    <span class="c1"># comparison operator that sorts on first entry first, etc.</span>
    <span class="k">def</span> <span class="nf">min_lexsort</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">datatype</span><span class="p">):</span>
        <span class="k">for</span> <span class="n">xi</span><span class="p">,</span> <span class="n">yi</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">xi</span> <span class="o">&lt;</span> <span class="n">yi</span><span class="p">:</span>
                <span class="k">return</span> <span class="n">x</span>
            <span class="k">elif</span> <span class="n">yi</span> <span class="o">&lt;</span> <span class="n">xi</span><span class="p">:</span>
                <span class="k">return</span> <span class="n">y</span>
        <span class="c1"># all entries the same:</span>
        <span class="k">return</span> <span class="n">x</span>
    <span class="n">min_lexsort_op</span> <span class="o">=</span> <span class="n">MPI</span><span class="o">.</span><span class="n">Op</span><span class="o">.</span><span class="n">Create</span><span class="p">(</span><span class="n">min_lexsort</span><span class="p">,</span> <span class="n">commute</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">move_to_nearest_cell_center</span><span class="p">(</span><span class="n">location</span><span class="p">):</span>
        <span class="n">loc_const</span><span class="o">.</span><span class="n">assign</span><span class="p">(</span><span class="n">location</span><span class="p">)</span>
        <span class="n">dist</span><span class="o">.</span><span class="n">interpolate</span><span class="p">(</span><span class="n">dot</span><span class="p">(</span><span class="n">xy</span><span class="o">-</span><span class="n">loc_const</span><span class="p">,</span> <span class="n">xy</span><span class="o">-</span><span class="n">loc_const</span><span class="p">))</span>
        <span class="n">ind</span> <span class="o">=</span> <span class="n">dist</span><span class="o">.</span><span class="n">dat</span><span class="o">.</span><span class="n">data_ro</span><span class="o">.</span><span class="n">argmin</span><span class="p">()</span>
        <span class="c1"># smallest distance to a cell centre location on this process:</span>
        <span class="n">local_loc</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">p0xy</span><span class="o">.</span><span class="n">dat</span><span class="o">.</span><span class="n">data_ro</span><span class="p">[</span><span class="n">ind</span><span class="p">])</span>
        <span class="n">local_dist</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">dist</span><span class="o">.</span><span class="n">dat</span><span class="o">.</span><span class="n">data_ro</span><span class="p">[</span><span class="n">ind</span><span class="p">])</span>
        <span class="c1"># select the smallest distance on all processes. If some distances are equal, pick a unique loc. based on lexsort</span>
        <span class="n">global_dist_loc</span> <span class="o">=</span> <span class="n">mesh</span><span class="o">.</span><span class="n">comm</span><span class="o">.</span><span class="n">allreduce</span><span class="p">([</span><span class="n">local_dist</span><span class="p">]</span><span class="o">+</span><span class="n">local_loc</span><span class="p">,</span> <span class="n">op</span><span class="o">=</span><span class="n">min_lexsort_op</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">global_dist_loc</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">global_dist_loc</span><span class="p">[</span><span class="mi">1</span><span class="p">:]</span>

    <span class="n">accepted_locations</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="n">accepted_names</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="k">if</span> <span class="n">detector_names</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">names</span> <span class="o">=</span> <span class="p">[</span><span class="kc">None</span><span class="p">]</span> <span class="o">*</span> <span class="nb">len</span><span class="p">(</span><span class="n">detector_locations</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">names</span> <span class="o">=</span> <span class="n">detector_names</span>
    <span class="k">for</span> <span class="n">location</span><span class="p">,</span> <span class="n">name</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">detector_locations</span><span class="p">,</span> <span class="n">names</span><span class="p">):</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="n">v</span><span class="p">(</span><span class="n">location</span><span class="p">)</span>
        <span class="k">except</span> <span class="n">PointNotInDomainError</span><span class="p">:</span>
            <span class="n">moved_dist</span><span class="p">,</span> <span class="n">location</span> <span class="o">=</span> <span class="n">move_to_nearest_cell_center</span><span class="p">(</span><span class="n">location</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">moved_dist</span> <span class="o">&gt;</span> <span class="n">maximum_distance</span><span class="p">:</span>
                <span class="k">continue</span>
        <span class="n">accepted_locations</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">location</span><span class="p">)</span>
        <span class="n">accepted_names</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">name</span><span class="p">)</span>

    <span class="n">min_lexsort_op</span><span class="o">.</span><span class="n">Free</span><span class="p">()</span>

    <span class="k">if</span> <span class="n">detector_names</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">accepted_locations</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">accepted_locations</span><span class="p">,</span> <span class="n">accepted_names</span></div>
</pre></div>

          </div>
        </div>
      </div>
    </div>
      <div class="clearer"></div>
    </div>
    <div class="footer" role="contentinfo">
        &#169; Copyright 2016-2018, Tuomas Karna et al..
      Created using <a href="http://sphinx-doc.org/">Sphinx</a> 1.7.4.
    </div>
  </body>
</html>